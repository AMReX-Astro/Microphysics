
! NOTE: THIS FILE IS AUTOMATICALLY GENERATED
! DO NOT EDIT BY HAND

! Re-run esum.py to update this file

! Fortran 2003 implementation of the msum routine
! provided by Raymond Hettinger:
! https://code.activestate.com/recipes/393090/
! This routine calculates the sum of N numbers
! exactly to within double precision arithmetic.
!
! For perfomance reasons we implement a specialized
! version of esum for each possible value of N >= 3.
!
! Also for performance reasons, we explicitly unroll
! the outer loop of the msum method into groups of 3
! (and a group of 4 at the end, for even N). This seems
! to be significantly faster, but should still be exact
! to within the arithmetic because each one of the
! individual msums is (although this does not necessarily
! mean that the result is the same).
!
! This routine is called "esum" for generality
! because in principle we could add implementations
! other than msum that do exact arithmetic, without
! changing the interface as seen in the networks.

module esum_module

  use amrex_fort_module, only : rt => amrex_real
  use amrex_constants_module, only: ZERO

  implicit none

  public

contains

  pure function esum3(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(3)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum3



  pure function esum4(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(4)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum4



  pure function esum5(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(5)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum5



  pure function esum6(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(6)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum6



  pure function esum7(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(7)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum7



  pure function esum8(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(8)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum8



  pure function esum9(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(9)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum9



  pure function esum10(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(10)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum10



  pure function esum11(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(11)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum11



  pure function esum12(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(12)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum12



  pure function esum13(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(13)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum13



  pure function esum14(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(14)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum14



  pure function esum15(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(15)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum15



  pure function esum16(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(16)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum16



  pure function esum17(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(17)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum17



  pure function esum18(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(18)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum18



  pure function esum19(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(19)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum19



  pure function esum20(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(20)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum20



  pure function esum21(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(21)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum21



  pure function esum22(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(22)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum22



  pure function esum23(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(23)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum23



  pure function esum24(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(24)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum24



  pure function esum25(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(25)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+22)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum25



  pure function esum26(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(26)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+22)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum26



  pure function esum27(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(27)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+22)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+24)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum27



  pure function esum28(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(28)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+22)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+24)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum28



  pure function esum29(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(29)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+22)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+24)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+26)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum29



  pure function esum30(array) result(esum)

    implicit none

    real(rt), intent(in) :: array(30)
    real(rt) :: esum

    ! Indices for tracking the partials array.
    ! j keeps track of how many entries in partials are actually used.
    ! The algorithm we model this off of, written in Python, simply
    ! deletes array entries at the end of every outer loop iteration.
    ! The Fortran equivalent to this might be to just zero them out,
    ! but this results in a huge performance hit given how often
    ! this routine is called during in a burn. So we opt instead to
    ! just track how many of the values are meaningful, which j does
    ! automatically, and ignore any data in the remaining slots.
    integer :: i, j, k, km

    ! Note that for performance reasons we are not
    ! initializing any unused values in this array.
    real(rt) :: partials(0:4)

    ! Some temporary variables for holding intermediate data.
    real(rt) :: x, y, z

    ! These temporary variables need to be explicitly
    ! constructed for the algorithm to make sense.
    ! If the compiler optimizes away the statement
    ! lo = y - (hi - x), the approach fails. This could
    ! be avoided with the volatile keyword, but at the
    ! expense of forcing additional memory usage
    ! which would slow down the calculation. Instead
    ! we will rely on the compiler not to optimize
    ! the statement away. This should be true for gcc
    ! by default but is not necessarily true for all
    ! compilers. In particular, Intel does not do this
    ! by default, so you must use the -assume-protect-parens
    ! flag for ifort.
    real(rt) :: hi, lo

    !$gpu

    ! The first partial is just the first term.
    esum = array(1)


    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+0)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+2)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+4)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+6)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+8)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+10)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+12)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+14)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+16)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+18)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+20)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+22)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 3

       km = j
       j = 0

       x = array(i+24)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))



    j = 0
    partials(0) = esum

    do i = 2, 4

       km = j
       j = 0

       x = array(i+26)

       do k = 0, km
          y = partials(k)

          if (abs(x) < abs(y)) then
             ! Swap x, y
             z = y
             y = x
             x = z
          endif

          hi = x + y
          lo = y - (hi - x)

          if (lo .ne. 0.0_rt) then
             partials(j) = lo
             j = j + 1
          endif

          x = hi

       enddo

       partials(j) = x

    enddo

    esum = sum(partials(0:j))


  end function esum30



end module esum_module
