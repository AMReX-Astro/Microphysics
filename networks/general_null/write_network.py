#!/usr/bin/env python

import sys
import string
import getopt

Header="""
! DO NOT EDIT THIS FILE!!!  
!  
! This file is automatically generated by write_network.py at 
! compile-time.  
!  
! To modify the species carried by the network, edit the appropriate inputs 
! file.

"""


#=============================================================================
# the species class holds the properties of a single species
#=============================================================================
class species(object):

    def __init__(self):
        self.name = ""
        self.shortName = ""
        self.A = -1
        self.Z = -1

#=============================================================================
# convenience class for an auxilliary variable
#=============================================================================
class auxvar(object):
    
    def __init__(self):
        self.name = ""


#=============================================================================
# getNextLine returns the next, non-blank line, with comments stripped
#=============================================================================
def getNextLine(fin):

    line = fin.readline()

    pos = str.find(line, "#")

    while ((pos == 0) or (str.strip(line) == "") and line):

        line = fin.readline()
        pos = str.find(line, "#")

    line = line[:pos]

    return line



#=============================================================================
# getObjectIndex looks through the list and returns the index corresponding to
# the network object (species or auxvar) specified by name
#=============================================================================
def getObjectIndex(objList, name):

    index = -1

    n = 0
    while (n < len(objList)):
        
        if (objList[n].name == name):
            index = n
            break

        n += 1

    return index



#=============================================================================
# parseNetFile read all the species listed in a given network inputs file
# and adds the valid species to the species list
#=============================================================================
def parseNetFile(speciesList, auxvarsList, netFile):

    err = 0

    try: f = open(netFile, "r")
    except IOError:

        print("write_network.py: ERROR: file "+str(netFile)+" does not exist")
        sys.exit(2)
        
    print("write_network.py: working on network file "+str(netFile)+"...")

    line = getNextLine(f)

    while (line and not err):

        fields = line.split()

        # read the species or auxiliary variable from the line
        netObj, err = parseNetworkObject(fields)
        if netObj is None: return err

        objList = speciesList
        if type(netObj).__name__ is "auxvar": objList = auxvarsList

        # check to see if this species/auxvar is defined in the current list
        index = getObjectIndex(objList, netObj.name)

        if (index >= 0):
            print("write_network.py: ERROR: %s %s already defined." % 
                  (type(netObj).__name__,netObj.name))
            err = 1                
        # add the species or auxvar to the appropriate list    
        objList.append(netObj)

        line = getNextLine(f)

    return err



#=============================================================================
# parse the fields in a line of the network file for either species or 
# auxiliary variables.  Aux variables are prefixed by '__aux_' in the network
# file
#=============================================================================
def parseNetworkObject(fields):
    err = 0

    # check for aux variables first
    if fields[0].startswith("__aux_"):
        ret = auxvar()
        ret.name = fields[0][6:]
    # check for missing fields in species definition
    elif not (len(fields) == 4):
        print(" ".join(fields))
        print("write_network.py: ERROR: missing one or more fields in species definition.")
        ret = None
        err = 1
    else:
        ret = species()
            
        ret.name      = fields[0]
        ret.shortName = fields[1]
        ret.A         = fields[2]
        ret.Z         = fields[3]

    return ret,err


    

#=============================================================================
# abort exits when there is an error.  A dummy stub file is written out, which
# will cause a compilation failure
#=============================================================================
def abort(outfile):

    fout = open(outfile, "w")
    fout.write("There was an error parsing the network files")
    fout.close()
    sys.exit(1)

    

#=============================================================================
# write_network will read through the list of species and output the 
# new outFile
#=============================================================================
def write_network(networkTemplate, netFile, outFile):

    speciesList = []
    auxvarsList = []

    print(" ")
    print("write_network.py: creating %s" % (outFile))


    #-------------------------------------------------------------------------
    # read the species defined in the netFile
    #-------------------------------------------------------------------------
    err = parseNetFile(speciesList, auxvarsList, netFile)
        
    if (err):
        abort(outFile)


    #-------------------------------------------------------------------------
    # open up the template
    #-------------------------------------------------------------------------
    try: ftemplate = open(networkTemplate, "r")
    except IOError:
        print("write_network.py: ERROR: file "+str(networkTemplate)+" does not exist")
        sys.exit(2)
    else:
        ftemplate.close()

    ftemplate = open(networkTemplate, "r")

    templateLines = []
    line = ftemplate.readline()
    while (line):
        templateLines.append(line)
        line = ftemplate.readline()


    #-------------------------------------------------------------------------
    # output the template, inserting the species info in between the @@...@@
    #-------------------------------------------------------------------------
    fout = open(outFile, "w")

    fout.write(Header)

    for line in templateLines:

        index = line.find("@@")

        if (index >= 0):
            index2 = line.rfind("@@")

            keyword = line[index+len("@@"):index2]
            indent = index*" "

            if (keyword == "NSPEC"):

                fout.write(string.replace(line,"@@NSPEC@@", str(len(speciesList))))
            
            elif (keyword == "NAUX"):

                fout.write(string.replace(line,"@@NAUX@@", str(len(auxvarsList))))

            elif (keyword == "SPEC_NAMES"):

                n = 0
                while (n < len(speciesList)):

                    fout.write("%sspec_names(%d) = \"%s\"\n" % 
                               (indent, n+1, speciesList[n].name))

                    n += 1


            elif (keyword == "SHORT_SPEC_NAMES"):

                n = 0
                while (n < len(speciesList)):

                    fout.write("%sshort_spec_names(%d) = \"%s\"\n" % 
                               (indent, n+1, speciesList[n].shortName))

                    n += 1


            elif (keyword == "AION"):

                n = 0
                while (n < len(speciesList)):

                    fout.write("%saion(%d) = %s\n" % 
                               (indent, n+1, speciesList[n].A))

                    n += 1


            elif (keyword == "ZION"):

                n = 0
                while (n < len(speciesList)):

                    fout.write("%szion(%d) = %s\n" % 
                               (indent, n+1, speciesList[n].Z))

                    n += 1

            elif (keyword == "AUX_NAMES"):
                
                n = 0
                while (n < len(auxvarsList)):
                    
                    fout.write("%saux_names(%d) = \"%s\"\n" % 
                               (indent, n+1, auxvarsList[n].name))
                    fout.write("%sshort_aux_names(%d) = \"%s\"\n" % 
                               (indent, n+1, auxvarsList[n].name))

                    n += 1 

        else:
            fout.write(line)


    
    print(" ")
    fout.close()




if __name__ == "__main__":

    try: opts, next = getopt.getopt(sys.argv[1:], "t:o:s:")

    except getopt.GetoptError:
        print("write_network.py: invalid calling sequence")
        sys.exit(2)

    networkTemplate = ""
    outFile = ""
    netFile = ""

    for o, a in opts:

        if o == "-t":
            networkTemplate = a

        if o == "-o":
            outFile = a

        if o == "-s":
            netFile = a


    if (networkTemplate == "" or outFile == ""):
        print("write_probin.py: ERROR: invalid calling sequence")
        sys.exit(2)

    write_network(networkTemplate, netFile, outFile)



