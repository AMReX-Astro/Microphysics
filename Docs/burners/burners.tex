This chapter describes the strategy we use to integrate the equations
corresponding to a nuclear reaction network and explains the software
interfaces we use to do so. It is intended to elaborate on the nature
of the \texttt{actual\_rhs.f90} and \texttt{actual\_burner.f90} files
mentioned in Section \ref{section:network_structure}.

\section{Burn Equations}

The equations we integrate to do a nuclear burn are:
\begin{eqnarray}
  \frac{dY_k}{dt} &=& \omegadot_k(\rho,Y_k,T), \label{eq:spec_integrate} \\
  \frac{de}{dt} &=& \sum_k \xi_k A_k \dot{Y}_k \label{eq:enuc_integrate} \\
  \frac{dT}{dt} &=&\frac{\dot{e}}{c}. \label{eq:temp_integrate}
\end{eqnarray}
$Y_k \equiv X_k / A_k$ is the molar fraction of species $k$, where
$X_k$ is the mass fraction and $A_k$ is the mass number of that species.
(Note that while $Y_k$ is the integration variable, this is invisible to
the code that calls the burner; it hands the burner the mass fractions $X_k$
and gets back updated mass fractions.)
$e$ is the internal energy, $T$ is the temperature\footnote{Note that in
previous versions of our networks in Castro and Maestro,
there was another term in the temperature equation relating to the
chemical potential of the gas as it came from the EOS. We have since
decided that this term should analytically cancel to zero in all cases
for our nuclear networks, and so we no longer think it is correct to
include a numerical approximation of it in the integration scheme. So
the current results given by our networks will in general be a little
different than in the past.}
, and $c$ is the specific heat for the fluid. $\xi_k$ is the energy
release associated with the destruction of species $k$; normally it
is given by the (absolute value of the) binding energy for that species.

While this is the most common way to construct the set of
burn equations, and is used in most of our production networks,
all of them are ultimately implemented by the network itself, which
can choose to disable the evolution of any of these equations by
setting the RHS to zero. The integration software provides some
helper routines that construct common RHS evaluations, like the RHS
of the temperature equation given $\dot{e}$, but these calls
are always explicitly done by the individual networks rather than
being handled by the integration backend. This allows you to write a
new network that defines the RHS in whatever way you like.

We integrate these using a stiff ordinary differential equation
integration solver. The absolute error tolerances are set by default
to $10^{-12}$ for the species, and a relative tolerance of $10^{-6}$
is used for the temperature and energy.  The integration
yields the new values of the mass fractions, $Y_k^\outp$.

\subsection{Burn Parameters}

The full set of parameters for the integration is listed in Chapter \ref{chapter:parameters}.
In this section we will explain the most relevant ones in more detail.
Remember that all of these are controlled by including them in your runtime
inputs (either with all other parameters in the standard inputs file for
MAESTRO, or the \texttt{extern} namelist of the probin file for CASTRO).

In evolving these equations, we need to evaluate $c$. This involves two
issues. First, we need to decide which specific heat we are talking about;
usually we deal with either the specific heat at constant pressure ($c_p$)
or the specific heat at constant volume ($c_v$). The EOS generally will
provide both of these specific heats; which one to use is a choice the user
needs to make based on the physics of their problem. It is controlled by the
parameter \texttt{do\_constant\_volume\_burn}, which will use $c_v$ if true
and $c_p$ is false. Second, a fully accurate integration of Equation
\ref{eq:temp_integrate} requires an evaluation of the specific heat at
each integration step, which involves an EOS call given the current temperature.
However, this may add significantly to the expense of the calculation,
especially for smaller networks where construction of the RHS is inexpensive,
and the user may decide that they are OK with a less accurate integration
(or they believe the specific heat won't change that much anyway during a burn).
This can be enabled or disabled with the parameter \texttt{call\_eos\_in\_rhs}.
A middle ground between fully on and fully off for this parameter is obtained
with the runtime parameter \texttt{dT\_crit}, which is the fractional change
needed in the temperature during a burn to trigger an EOS call that updates
the thermodynamic variables. Note that this is fully independent of
\texttt{call\_eos\_in\_rhs}. If you use this option, we do a crude prediction
of the specific heat in between EOS calls using a numerically constructed
approximation to the temperature derivative of the specific heat.

The \texttt{renormalize\_abundances} parameter controls whether we renormalize
the abundances so that the mass fractions sum to one during a burn. This
has the positive benefit that in some cases it can prevent the integrator
from going off to infinity or otherwise go crazy; a possible negative benefit
is that it may slow down convergence because it interferes with the integration
scheme. Regardless of whether you enable this, we will always ensure that the
mass fractions stay positive and larger than some floor \texttt{small\_x}.

While we normally evolve all of these equations simultaneously, which is
usually called a ``self-heating'' burn because the temperature is allowed
to respond to the reactions as they occur, it is
sometimes the case that you do not want to update the temperature at all
during the burn -- this is a so-called ``hydrostatic'' burn. You can
set the RHS of the temperature equation to zero by setting
\texttt{burning\_mode = 0}. We also offer the ``hybrid'' burn approach
(\texttt{burning\_mode = 2}) introduced by \cite{raskin:2010}, which
does a hydrostatic burn, but recomputes a self-heating burn if the
final energy release from the hydrostatic burn was negative (the
logic being that a negative energy release corresponds to NSE conditions).

The integration tolerances for the burn are controlled by \texttt{rtol\_spec},
\texttt{rtol\_enuc}, and \texttt{rtol\_temp}, which are the relative error
tolerances for Equations \ref{eq:spec_integrate}, \ref{eq:enuc_integrate},
and \ref{eq:temp_integrate}, respectively. There are corresponding \texttt{atol}
parameters for the absolute error tolerances. Note that not all integrators
handle error tolerances the same way; see Section \ref{sec:stiff_solvers} for
notes on any differences between them.

\section{Stiff ODE Solvers}
\label{sec:stiff_solvers}

Let's turn to the set of options we have for evolving our system of coupled,
stiff ODEs. You can control which integrator you use by setting the
\texttt{INTEGRATOR\_DIR} variable in your makefile equal to the name of
one of the following integrators from the list (this corresponds to the
directory names in \texttt{integrators/}).

\subsection{VODE}
\label{sec:VODE}

\subsection{VBDF}
\label{sec:VBDF}

\subsection{BS}
\label{sec:BS}

\section{Burn Interfaces}
\label{sec:burn_interfaces}

\subsection{The burn\_t type}
\label{sec:burn_t}
