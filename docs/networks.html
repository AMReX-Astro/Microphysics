

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reaction Networks &mdash; StarKiller Microphysics 18.10 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="StarKiller Microphysics 18.10 documentation" href="index.html"/>
        <link rel="next" title="Transport Coefficients" href="transport.html"/>
        <link rel="prev" title="Equations of State" href="eos.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> StarKiller Microphysics
          

          
          </a>

          
            
            
              <div class="version">
                18.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">StarKiller basics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">StarKiller Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="eos.html">Equations of State</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reaction Networks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#network-requirements-and-structure">Network Requirements and Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#available-networks">Available Networks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aprox13-aprox19-and-aprox21">aprox13, aprox19, and aprox21</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#energy-generation">Energy generation.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#breakout">breakout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cone2nse">CONe2NSE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-null">general_null</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ignition-chamulak">ignition_chamulak</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#energy-generation-1">Energy generation.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ignition-reaclib">ignition_reaclib</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ignition-simple">ignition_simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iso7">iso7</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kpp">kpp</a></li>
<li class="toctree-l3"><a class="reference internal" href="#powerlaw">powerlaw</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rprox">rprox</a></li>
<li class="toctree-l3"><a class="reference internal" href="#triple-alpha-plus-cago">triple_alpha_plus_cago</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xrb-simple">xrb_simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subch">subch</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reaction-ode-system">Reaction ODE System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thermodynamics-and-evolution">Thermodynamics and <span class="math">\(T\)</span> Evolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nspec-evolve-implementation">nspec_evolve Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#renormalization">Renormalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tolerances">Tolerances</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stiff-ode-solvers">Stiff ODE Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#actual-integrator">actual_integrator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#righthand-side-wrapper">Righthand side wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bs">BS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bs-t-data-structure">bs_t data structure.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-criteria">Error criteria.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vode">VODE</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-structures">data structures.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id30">tolerances.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vbdf">VBDF</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retries">Retries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overriding-parameter-defaults-on-a-network-by-network-basis">Overriding Parameter Defaults on a Network-by-Network Basis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="transport.html">Transport Coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="openacc.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="unit_tests.html">Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="burn_cell.html">Burn Cell Utility</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">StarKiller Microphysics</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Reaction Networks</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/networks.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="reaction-networks">
<h1>Reaction Networks<a class="headerlink" href="#reaction-networks" title="Permalink to this headline">¶</a></h1>
<div class="section" id="network-requirements-and-structure">
<h2>Network Requirements and Structure<a class="headerlink" href="#network-requirements-and-structure" title="Permalink to this headline">¶</a></h2>
<p>A network both defines the composition advected by the hydro code as
well as describes the burning processes between those isotopes.
Evolving the species in a network requires an integrator. The design
of Microphysics&nbsp;decouples the integrator from the network, allowing
for the ability to swap integrators as desired. We discuss the
integrators in a later section.</p>
<p>At a minimum, a network needs to provide:</p>
<ul>
<li><p class="first">nspec : the number of species in the network</p>
</li>
<li><p class="first">nspec_evolve : the number of species that are actually
integrated in the network. Usually this is nspec, but in general
any nspec_evolve <span class="math">\(\le\)</span> nspec is allowed. Those species
not evolved are held constant in the integration.</p>
<p>Note that the convention is that the first nspec_evolve out
of the nspec species are the ones evolved.</p>
</li>
<li><p class="first">nrates : the number of reaction rates. This is used to
allocate space in the rate_t type</p>
</li>
<li><p class="first">num_rate_groups : the number of components for each reaction
rate we want to store in the rate_t type</p>
</li>
<li><p class="first">naux : the number of auxiliary quantities needed by the
network (these are not evolved).</p>
</li>
<li><p class="first">aion(:) : the atomic weight (in atomic mass units) of the
species</p>
</li>
<li><p class="first">zion(:) : the atomic number of the species</p>
</li>
<li><p class="first">spec_names(:) : a descriptive name of the species
(e.g. “hydrogen-1”)</p>
</li>
<li><p class="first">short_spec_names(:) : a shorten version of the species name
(e.g. “H1”)</p>
</li>
<li><p class="first">short_aux_names(:) : the names of the auxiliary quantities</p>
</li>
<li><p class="first">network_name : a descriptive name for the network</p>
</li>
</ul>
<p>Most of these quantities are Fortran parameters.</p>
<p><strong>A convention adopted in Microphysics&nbsp;is that each network
is responsible for determining the energy release from a change
in composition</strong>. Most networks will provide an array of the species
binding energies and a routine to compute the energy yield from
the reaction rates.</p>
<p>There are three primary files within each network directory.</p>
<ul>
<li><p class="first">actual_network.f90:</p>
<p>This is the Fortran module actual_network with routines:</p>
<ul class="simple">
<li>actual_network_init()</li>
<li>actual_network_finalize()</li>
</ul>
<p>This supplies the number and names of species and auxiliary
variables, as well as other initializing data, such as their mass
numbers, proton numbers, and binding energies. It needs to define
the nspec and naux quantities as integer
parameters. Additionally it must define nspec_evolve, the
number of species that are actually evolved during a burn; in most
cases, this should have the same value as nspec. Finally, it
must also define nrates, the number of reaction rates linking
the isotopes in the network.</p>
</li>
<li><p class="first">actual_rhs.f90:</p>
<p>This is the Fortran module actual_rhs_module, with routines:</p>
<ul class="simple">
<li>actual_rhs_init()</li>
<li>actual_rhs(state)</li>
<li>actual_jac(state)</li>
</ul>
<p>This supplies an interface for computing the right-hand-side of the
network, the time-derivative of each species (and the temperature
and nuclear energy release), as well as the analytic Jacobian.
Both actual_rhs and actual_jac take a single argument,
a burn_t state. They set the time-derivatives and Jacobian
elements in this derived type directly.</p>
<p>Note: some networks do not provide an analytic Jacobian and instead
rely on the numerical difference-approximation to the Jacobian. In
this case, the interface actual_jac is still needed to compile.</p>
</li>
<li><p class="first">actual_burner:</p>
<p>This is the Fortran module actual_burner_module, with routines:</p>
<ul class="simple">
<li>actual_burner_init()</li>
<li>actual_burner(state_in, state_out, dt, time)</li>
</ul>
<p>This contains the interface for doing an actual burn. Here,
state_in and state_out are burn_t objects. In
general, you will want to call integrator to use one of the
pre-defined ODE integrators, but you could also write a custom
integration here. This is covered in more detail in §&nbsp;<a class="reference external" href="#ch:networks:integrators">5</a>.</p>
</li>
</ul>
<p>Notice that all three of these modules have initialization routines:</p>
<ul class="simple">
<li>actual_network_init()</li>
<li>actual_rhs_init()</li>
<li>actual_burner_init()</li>
</ul>
<p>These must be called upon initialization. These should be not called
within OpenMP parallel regions, because in general they will modify
shared module data.</p>
<p>Note, depending on the network, some of these may do nothing, but
these interfaces are all required for maximum flexibility.</p>
</div>
<div class="section" id="available-networks">
<h2>Available Networks<a class="headerlink" href="#available-networks" title="Permalink to this headline">¶</a></h2>
<div class="section" id="aprox13-aprox19-and-aprox21">
<h3>aprox13, aprox19, and aprox21<a class="headerlink" href="#aprox13-aprox19-and-aprox21" title="Permalink to this headline">¶</a></h3>
<p>These are alpha-chains (with some other nuclei) from Frank Timmes.
These networks share common rates (from Microphysics/rates),
plasma neutrino loses (from Microphysics/neutrinos), and
electron screening (from Microphysics/screening).</p>
<div class="section" id="energy-generation">
<h4>Energy generation.<a class="headerlink" href="#energy-generation" title="Permalink to this headline">¶</a></h4>
<p>These networks store the total binding
energy of the nucleus in MeV as bion(:). They then compute the
mass of each nucleus in grams as:</p>
<div class="math">
\[M_k = (A_k - Z_k) m_n + Z_k (m_p + m_e) - B_k\]</div>
<p>where <span class="math">\(m_n\)</span>, <span class="math">\(m_p\)</span>, and <span class="math">\(m_e\)</span> are the neutron, proton, and electron
masses, <span class="math">\(A_k\)</span> and <span class="math">\(Z_k\)</span> are the atomic weight and number, and <span class="math">\(B_k\)</span>
is the binding energy of the nucleus (converted to grams). <span class="math">\(M_k\)</span>
is stored as mion(:) in the network.</p>
<p>The energy release per gram is converted from the rates as:</p>
<div class="math">
\[\edot = -N_A c^2 \sum_k \frac{dY_k}{dt} M_k - \edotnu\]</div>
<p>where <span class="math">\(N_A\)</span> is Avogadro’s number (to convert this to “per gram”)
and <span class="math">\(\edotnu\)</span> is the neutrino loss term.</p>
</div>
</div>
<div class="section" id="breakout">
<h3>breakout<a class="headerlink" href="#breakout" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="cone2nse">
<h3>CONe2NSE<a class="headerlink" href="#cone2nse" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="general-null">
<h3>general_null<a class="headerlink" href="#general-null" title="Permalink to this headline">¶</a></h3>
<p>general_null is a bare interface for a nuclear reaction
network; no reactions are enabled, and no auxiliary variables are
accepted. The data in the Fortran module is defined at compile type
by specifying an inputs file. For example,
Networks/general_null/triple_alpha_plus_o.net would describe
the triple-<span class="math">\(\alpha\)</span> reaction converting helium into carbon, as well as
oxygen and iron.</p>
<p>At compile time, the network module actual_network.f90
is written using the python script write_network.py
and the template network.template. The make rule
for this is contained in Make.package (for C++&nbsp;AMReX) and
GPackage.mak (for F90 AMReX). The name of the inputs file
is specified by the variable GENERAL_NET_INPUTS.</p>
<p>A version of this network comes with MAESTRO&nbsp;and CASTRO, so you do
not usually need to worry about the version in Microphysics.</p>
</div>
<div class="section" id="ignition-chamulak">
<h3>ignition_chamulak<a class="headerlink" href="#ignition-chamulak" title="Permalink to this headline">¶</a></h3>
<p>This network was introduced in our paper on convection in white dwarfs
as a model of Type Ia supernovae&nbsp;<a href="#id1"><span class="problematic" id="id2">:raw-latex:`\cite{wdconvect}`</span></a>. It models
carbon burning in a regime appropriate for a simmering white dwarf,
and captures the effects of a much larger network by setting the ash
state and energetics to the values suggested in <a href="#id3"><span class="problematic" id="id4">:raw-latex:`\cite{chamulak:2008}`</span></a>.</p>
<p>This network has nspec = 3, but nspec_evolve = 1. Only a
single reaction is modeled, converting <span class="math">\(^{12}\mathrm{C}\)</span> into “
ash”.</p>
<div class="section" id="energy-generation-1">
<span id="id5"></span><h4>Energy generation.<a class="headerlink" href="#energy-generation-1" title="Permalink to this headline">¶</a></h4>
<p>The binding energy, <span class="math">\(q\)</span>, in this
network is interpolated based on the density. It is stored as the
binding energy (ergs/g) <em>per nucleon</em>, with a sign convention that
binding energies are negative. The energy generation rate is then:</p>
<div class="math">
\[\edot = q \frac{dX(\isotm{C}{12})}{dt} = q A_{\isotm{C}{12}} \frac{dY(\isotm{C}{12})}{dt}\]</div>
<p>(this is positive since both <span class="math">\(q\)</span> and <span class="math">\(dY/dt\)</span> are negative)</p>
</div>
</div>
<div class="section" id="ignition-reaclib">
<h3>ignition_reaclib<a class="headerlink" href="#ignition-reaclib" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="ignition-simple">
<h3>ignition_simple<a class="headerlink" href="#ignition-simple" title="Permalink to this headline">¶</a></h3>
<p>This is the original network used in our white dwarf convection
studies&nbsp;<a href="#id6"><span class="problematic" id="id7">:raw-latex:`\cite{lowMach4}`</span></a>. It includes a single-step
<span class="math">\(^{12}\mathrm{C}(^{12}\mathrm{C},\gamma)^{24}\mathrm{Mg}\)</span> reaction.
The carbon mass fraction equation appears as</p>
<div class="math">
\[\frac{D X(^{12}\mathrm{C})}{Dt} = - \frac{1}{12} \rho X(^{12}\mathrm{C})^2
    f_\mathrm{Coul} \left [N_A \left &lt;\sigma v \right &gt; \right]\enskip,\]</div>
<p>where <span class="math">\(N_A \left &lt;\sigma v\right&gt;\)</span> is evaluated using the reaction
rate from (Caughlan and Fowler 1988). The Coulomb screening factor,
<span class="math">\(f_\mathrm{Coul}\)</span>, is evaluated using the general routine from the
Kepler stellar evolution code (Weaver 1978), which implements the work
of (Graboske 1973) for weak screening and the work of (Alastuey 1978
and Itoh 1979) for strong screening.</p>
</div>
<div class="section" id="iso7">
<h3>iso7<a class="headerlink" href="#iso7" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="kpp">
<h3>kpp<a class="headerlink" href="#kpp" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="powerlaw">
<h3>powerlaw<a class="headerlink" href="#powerlaw" title="Permalink to this headline">¶</a></h3>
<p>This is a simple single-step reaction rate.
We will consider only two species, fuel, <span class="math">\(f\)</span>, and ash, <span class="math">\(a\)</span>, through
the reaction: <span class="math">\(f + f \rightarrow a + \gamma\)</span>. Baryon conservation
requres that <span class="math">\(A_f = A_a/2\)</span>, and charge conservation requires that <span class="math">\(Z_f
= Z_a/2\)</span>. We take
our reaction rate to be a powerlaw in temperature. The standard way
to write this is in terms of the number densities, in which case we
have</p>
<div class="math">
\[\frac{d n_f}{d t} = -2\frac{d n_a}{d t} = -r\]</div>
<p>with</p>
<div class="math">
\[r = r_0 n_X^2 \left( \frac{T}{T_0} \right )^\nu\]</div>
<p>Here, <span class="math">\(r_0\)</span> sets the overall rate, with units of
<span class="math">\([\mathrm{cm^3~s^{-1}}]\)</span>, <span class="math">\(T_0\)</span> is a reference temperature scale, and
<span class="math">\(\nu\)</span> is the temperature exponent, which will play a role in setting
the reaction zone thickness. In terms of mass fractions, <span class="math">\(n_f = \rho
X_a / (A_a m_u)\)</span>, our rate equation is</p>
<div class="math">
\[\begin{split}\begin{aligned}
 \frac{dX_f}{dt} &amp;=&amp; - \frac{r_0}{m_u} \rho X_f^2 \frac{1}{A_f} \left (\frac{T}{T_0}\right)^\nu \equiv \omegadot_f \label{eq:Xf} \\
 \frac{dX_a}{dt} &amp;=&amp; \frac{1}{2}\frac{r_0}{m_u} \rho X_f^2 \frac{A_a}{A_f^2} \left (\frac{T}{T_0}\right)^\nu = \frac{r_0}{m_u} \rho X_f^2 \frac{1}{A_f} \left (\frac{T}{T_0}\right)^\nu  \label{eq:Xa}\end{aligned}\end{split}\]</div>
<p>We define a new rate constant, <span class="math">\(\rt\)</span> with units of <span class="math">\([\mathrm{s^{-1}}]\)</span> as</p>
<div class="math">
\[\begin{split}\rt =  \begin{cases}
  \dfrac{r_0}{m_u A_f} \rho_0 &amp; \text{if $T \ge T_a$} \\[1em]
  0                          &amp; \text{if $T &lt; T_a$}
 \end{cases}\end{split}\]</div>
<p>where <span class="math">\(\rho_0\)</span> is a reference density and <span class="math">\(T_a\)</span> is an activation
temperature, and then our mass fraction equation is:</p>
<div class="math">
\[\frac{dX_f}{dt} = -\rt X_f^2 \left (\frac{\rho}{\rho_0} \right ) \left ( \frac{T}{T_0}\right )^\nu\]</div>
<p>Finally, for the
energy generation, we take our reaction to release a specific energy,
<span class="math">\([\mathrm{erg~g^{-1}}]\)</span>, of <span class="math">\(\qburn\)</span>, and our energy source is</p>
<div class="math">
\[\edot = -\qburn \frac{dX_f}{dt}\]</div>
<p>There are a number of parameters we use to control the constants in
this network. This is one of the few networks that was designed
to work with gamma_law_general as the EOS.</p>
</div>
<div class="section" id="rprox">
<h3>rprox<a class="headerlink" href="#rprox" title="Permalink to this headline">¶</a></h3>
<p>This network contains 10 species, approximating hot CNO,
triple-<span class="math">\(\alpha\)</span>, and rp-breakout burning up through <span class="math">\(^{56}\mathrm{Ni}\)</span>,
using the ideas from <a href="#id8"><span class="problematic" id="id9">:raw-latex:`\cite{wallacewoosley:1981}`</span></a>, but with modern
reaction rates from ReacLib&nbsp;<a href="#id10"><span class="problematic" id="id11">:raw-latex:`\cite{ReacLib}`</span></a> where available.
This network was used for the X-ray burst studies in
<a href="#id12"><span class="problematic" id="id13">:raw-latex:`\cite{xrb:II,xrb:III}`</span></a>, and more details are contained in those papers.</p>
</div>
<div class="section" id="triple-alpha-plus-cago">
<h3>triple_alpha_plus_cago<a class="headerlink" href="#triple-alpha-plus-cago" title="Permalink to this headline">¶</a></h3>
<p>This is a 2 reaction network for helium burning, capturing the <span class="math">\(3\)</span>-<span class="math">\(\alpha\)</span>
reaction and <span class="math">\(\isotm{C}{12}(\alpha,\gamma)\isotm{O}{16}\)</span>. Additionally,
<span class="math">\(^{56}\mathrm{Fe}\)</span> is included as an inert species.</p>
<p>This network has nspec = 4, but nspec_evolve = 3.</p>
</div>
<div class="section" id="xrb-simple">
<h3>xrb_simple<a class="headerlink" href="#xrb-simple" title="Permalink to this headline">¶</a></h3>
<p>This is a simple 7 isotope network approximating the burning that
takes place in X-ray bursts (6 isotopes participate in reactions, one
additional, <span class="math">\(^{56}\mathrm{Fe}\)</span>, serves as an inert composition). The 6 reactions
modeled are:</p>
<ul class="simple">
<li><span class="math">\(3\alpha + 2p \rightarrow \isotm{O}{14}\)</span> (limited by the 3-<span class="math">\(\alpha\)</span> rate)</li>
<li><span class="math">\(\isotm{O}{14} + \alpha \rightarrow \isotm{Ne}{18}\)</span>
(limited by <span class="math">\(\isotm{O}{14}(\alpha,p)\isotm{F}{17}\)</span> rate)</li>
<li><span class="math">\(\isotm{O}{15} + \alpha + 6 p \rightarrow \isotm{Si}{25}\)</span>
(limited by <span class="math">\(\isotm{O}{15}(\alpha,\gamma)\isotm{Ne}{19}\)</span> rate)</li>
<li><span class="math">\(\isotm{Ne}{18} + \alpha + 3p \rightarrow \isotm{Si}{25}\)</span>
(limited by <span class="math">\(\isotm{Ne}{18}(\alpha,p)\isotm{Na}{21}\)</span> rate)</li>
<li><span class="math">\(\isotm{O}{14} + p \rightarrow \isotm{O}{15}\)</span>
(limited by <span class="math">\(\isotm{O}{14}(e+\nu)\isotm{N}{14}\)</span> rate)</li>
<li><span class="math">\(\isotm{O}{15} + 3p \rightarrow \isotm{O}{14} + \alpha\)</span>
(limited by <span class="math">\(\isotm{O}{15}(e+\nu)\isotm{N}{15}\)</span> rate)</li>
</ul>
<p>All reactions conserve mass. Where charge is not conserved, fast weak
interactions are assumed. Weak rates are trivial, fits to the 4
strong rates to a power law in <span class="math">\(T_9 \in [0.3, 1]\)</span>, linear in density.</p>
</div>
<div class="section" id="subch">
<h3>subch<a class="headerlink" href="#subch" title="Permalink to this headline">¶</a></h3>
<p>This is a 10 isotope network including rates from reactions suggested by Shen and Bildsten in their 2009 paper on helium burning on a white dwarf <a href="#id14"><span class="problematic" id="id15">:raw-latex:`\cite{ShenBildsten}`</span></a>.
The reactions included in this networks are as follows:</p>
<div class="math">
\[\begin{split}\begin{aligned}
    \isotm{He}{4} &amp;\rightarrow  \isotm{C}{12} + 2\gamma \\
    \isotm{C}{12} + \isotm{He}{4} &amp;\rightarrow \isotm{O}{16} + \gamma \\
    \isotm{N}{14} + \isotm{He}{4} &amp;\rightarrow \isotm{F}{18} + \gamma \label{chemeq:1.1} \\
    \isotm{F}{18} + \isotm{He}{4} &amp;\rightarrow \isotm{Ne}{21} +  \text{p} \label{chemeq:1.2} \\
    \isotm{C}{12} + p+ &amp;\rightarrow \isotm{N}{13} + \gamma  \label{chemeq:2.1} \\
    \isotm{N}{13} + \isotm{He}{4} &amp;\rightarrow \isotm{O}{16} + \text{p} \label{chemeq:2.2} \\
    \isotm{O}{16} + \isotm{He}{4} &amp;\rightarrow \isotm{Ne}{20} + \gamma \\
    \isotm{C}{14} + \isotm{He}{4} &amp;\rightarrow \isotm{O}{18} + \gamma \label{chemeq:3.2}\end{aligned}\end{split}\]</div>
<p>The main reactions suggested by Shen and Bildsten were the reaction series of
chemical equation <a class="reference external" href="#chemeq:1.1">[chemeq:1.1]</a> leading into equation <a class="reference external" href="#chemeq:1.2">[chemeq:1.2]</a>,
chemical equation <a class="reference external" href="#chemeq:2.1">[chemeq:2.1]</a> leading into equation <a class="reference external" href="#chemeq:2.2">[chemeq:2.2]</a>,
and chemical equation <a class="reference external" href="#chemeq:3.2">[chemeq:3.2]</a> <a href="#id16"><span class="problematic" id="id17">:raw-latex:`\cite{ShenBildsten}`</span></a>.
The rates of these reactions are shown in Figure&nbsp;<a class="reference external" href="#pynuc-subch">[pynuc-subch]</a>.
Notably, the reaction rate of chemical equation <a class="reference external" href="#chemeq:2.2">[chemeq:2.2]</a> is high and may produce Oxygen-16 more quickly than reactions involving only Helium-4, and Carbon-12.</p>
<div class="figure" id="id33">
<a class="reference internal image-reference" href="subch.pdf"><img alt="pynucastro plot of the reaction rates of the subch network." src="subch.pdf" style="width: 3in;" /></a>
<p class="caption"><span class="caption-text">pynucastro plot of the reaction rates of the subch network.</span></p>
</div>
</div>
</div>
<div class="section" id="reaction-ode-system">
<h2>Reaction ODE System<a class="headerlink" href="#reaction-ode-system" title="Permalink to this headline">¶</a></h2>
<p>Note: the integration works on the state <span class="math">\(\rho\)</span>, <span class="math">\(T\)</span>, and <span class="math">\(X_k\)</span>, e.g., the
mass fractions, but the individual networks construct the rates in terms
of the molar fractions, <span class="math">\(Y_k\)</span>. The wrappers between the integrators and
network righthand side routines do the conversion of the state to mass
fractions for the integrator.</p>
<p>The equations we integrate to do a nuclear burn are:</p>
<div class="math">
\[\begin{split}\begin{aligned}
  \frac{dX_k}{dt} &amp;=&amp; \omegadot_k(\rho,X_k,T), \label{eq:spec_integrate} \\
  \frac{d\enuc}{dt} &amp;=&amp; f(\dot{X}_k) \label{eq:enuc_integrate} \\
  \frac{dT}{dt} &amp;=&amp;\frac{\edot}{c_x}. \label{eq:temp_integrate}\end{aligned}\end{split}\]</div>
<p>Here, <span class="math">\(X_k\)</span> is the mass fraction of species <span class="math">\(k\)</span>, <span class="math">\(\enuc\)</span> is the specifc
nuclear energy created through reactions, <span class="math">\(T\)</span> is the
temperature <a class="footnote-reference" href="#id31" id="id18">[1]</a> , and <span class="math">\(c_x\)</span> is the specific heat for the
fluid. The function <span class="math">\(f\)</span> provides the energy release based on the
instantaneous reaction terms, <span class="math">\(\dot{X}_k\)</span>. As noted in the previous
section, this is implemented in a network-specific manner.</p>
<p>In this system, <span class="math">\(\enuc\)</span> is not necessarily the total specific internal
energy, but rather just captures the energy release during the burn. In
this system, it acts as a diagnostic,</p>
<div class="math">
\[\enuc = \int \edot dt\]</div>
<p>so we know how much energy was released (or required) over the burn.</p>
<p>While this is the most common way to construct the set of
burn equations, and is used in most of our production networks,
all of them are ultimately implemented by the network itself, which
can choose to disable the evolution of any of these equations by
setting the RHS to zero. The integration software provides some
helper routines that construct common RHS evaluations, like the RHS
of the temperature equation given <span class="math">\(\dot{e}\)</span>, but these calls
are always explicitly done by the individual networks rather than
being handled by the integration backend. This allows you to write a
new network that defines the RHS in whatever way you like.</p>
<div class="section" id="interfaces">
<h3>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h3>
<p>The righthand side of the network is implemented by
actual_rhs() in actual_rhs.f90, and appears as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">actual_rhs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="nb">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="p">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>All of the necessary integration data comes in through state, as:</p>
<ul class="simple">
<li>state % xn(:) : the nspec mass fractions (note: for
the case that nspec_evolve &lt; nspec, an algebraic constraint
may need to be enforced. See §&nbsp;<a class="reference external" href="#ch:networks:nspec_evolve">3.3</a>).</li>
<li>state % e : the current value of the ODE system’s energy
release, <span class="math">\(\enuc\)</span>—note: as discussed above, this is not necessarily
the energy you would get by calling the EOS on the state. It is
very rare (never?) that a RHS implementation would need to use this
variable.</li>
<li>state % T : the current temperature</li>
<li>state % rho : the current density</li>
</ul>
<p>Note that we come in with the mass fractions, but the molar fractions can
be computed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">precision</span> <span class="p">::</span> <span class="n">y</span><span class="p">(</span><span class="n">nspec</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">y</span><span class="p">(:)</span> <span class="o">=</span> <span class="n">state</span> <span class="o">%</span> <span class="n">xn</span><span class="p">(:)</span> <span class="o">/</span> <span class="n">aion</span><span class="p">(:)</span>
</pre></div>
</div>
<p>The actual_rhs() routine’s job is to fill the righthand side vector
for the ODE system, state % ydot(:). Here, the important
fields to fill are:</p>
<ul class="simple">
<li>state % ydot(1:nspec_evolve) : the change in <em>molar
fractions</em> for the nspec_evolve species that we are evolving,
<span class="math">\(d({Y}_k)/dt\)</span></li>
<li>state % ydot(net_ienuc) : the change in the energy release
from the net, <span class="math">\(d\enuc/dt\)</span></li>
<li>state % ydot(net_itemp) : the change in temperature, <span class="math">\(dT/dt\)</span></li>
</ul>
<p>The righthand side routine is assumed to return the change in <em>molar fractions</em>,
<span class="math">\(dY_k/dt\)</span>. These will be converted to the change in mass fractions, <span class="math">\(dX_k/dt\)</span>
by the wrappers that call the righthand side routine for the integrator.
If the network builds the RHS in terms of mass fractions directly, <span class="math">\(dX_k/dt\)</span>, then
these will need to be converted to molar fraction rates for storage, e.g.,
<span class="math">\(dY_k/dt = A_k^{-1} dX_k/dt\)</span>.</p>
<p>The Jacobian is provided by actual_jac(state), and takes the
form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">actual_jac</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="nb">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="p">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>The Jacobian matrix elements are stored in state % jac as:</p>
<ul class="simple">
<li>state % jac(m, n) for <span class="math">\(\mathrm{m}, \mathrm{n} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math">\(d(\dot{Y}_m)/dY_n\)</span></li>
<li>state % jac(net_ienuc, n) for <span class="math">\(\mathrm{n} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math">\(d(\edot)/dY_n\)</span></li>
<li>state % jac(net_itemp, n) for <span class="math">\(\mathrm{n} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math">\(d(\dot{T})/dY_n\)</span></li>
<li>state % jac(m, net_itemp) for <span class="math">\(\mathrm{m} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math">\(d(\dot{Y}_m)/dT\)</span></li>
<li>state % jac(net_ienuc, net_itemp) :
<span class="math">\(d(\edot)/dT\)</span></li>
<li>state % jac(net_itemp, net_itemp) :
<span class="math">\(d(\dot{T})/dT\)</span></li>
<li>state % jac(p, net_ienuc) <span class="math">\(= 0\)</span> for <span class="math">\(\mathrm{p} \in [1, \mathrm{neqs}]\)</span>, since nothing
should depend on the integrated energy release</li>
</ul>
<p>The form looks like:</p>
<div class="math">
\[\begin{split}\vphantom{% phantom stuff for correct box dimensions
    \begin{matrix}
    \overbrace{XYZ}^{\mbox{$R$}}\\ \\ \\ \\ \\ \\
    \underbrace{pqr}_{\mbox{$S$}}
    \end{matrix}}%
\begin{matrix}% matrix for left braces
    \coolleftbrace{Y_m}{~ \\ ~ \\ ~}\\ \enuc \\ T \\
\end{matrix}%
\begin{pmatrix}
\coolover{Y_n}{\ddots &amp; \hphantom{\partial \dot{Y}_m}\vdots\hphantom{/\partial Y_n} &amp; \iddots } &amp; \vdots &amp; \vdots \\
    \hdots &amp; \partial \dot{Y}_m/\partial Y_n &amp; \hdots &amp; 0 &amp; \partial \dot{Y}_m/\partial T    \\
    \iddots &amp; \hphantom{\partial \dot{Y}_m}\vdots\hphantom{/\partial Y_n} &amp; \ddots &amp; \vdots &amp; \vdots  \\
    \hdots &amp; \partial \edot/\partial Y_n &amp; \hdots &amp; 0 &amp; \partial \edot/\partial T   \\
    \hdots &amp; \partial \dot{T}/\partial Y_n &amp; \hdots &amp; 0 &amp; \partial \dot{T}/\partial T   \\
\end{pmatrix}%\end{split}\]</div>
<p>This shows that all of the derivatives with respect to the nuclear
energy generated, <span class="math">\(e_\mathrm{nuc}\)</span> are zero. Again, this is because
this is just a diagnostic variable.</p>
<p>Note: a network is not required to compute a Jacobian if a numerical
Jacobian is used. This is set with the runtime parameter
jacobian = 2, and implemented in
integration/numerical_jacobian.f90 using finite-differences.</p>
</div>
<div class="section" id="thermodynamics-and-evolution">
<h3>Thermodynamics and <span class="math">\(T\)</span> Evolution<a class="headerlink" href="#thermodynamics-and-evolution" title="Permalink to this headline">¶</a></h3>
<p>There are several different modes under which the burning can be done, set
via the burning_mode runtime parameter:</p>
<ul>
<li><p class="first">burning_mode = 0 : hydrostatic burning</p>
<p><span class="math">\(\rho\)</span>, <span class="math">\(T\)</span> remain constant</p>
</li>
<li><p class="first">burning_mode = 1 : self-heating burn</p>
<p><span class="math">\(T\)</span> evolves with the burning according to the temperature evolution
equation. This is the “usual” way of thinking of the
burning—all three equations (Eqs. <a class="reference external" href="#eq:spec_integrate">[eq:spec_integrate]</a>,
<a class="reference external" href="#eq:enuc_integrate">[eq:enuc_integrate]</a>, and <a class="reference external" href="#eq:temp_integrate">[eq:temp_integrate]</a>) are solved
simultaneously.</p>
</li>
<li><p class="first">burning_mode = 2 : hybrid approach</p>
<p>This implements an approach from <a href="#id19"><span class="problematic" id="id20">:raw-latex:`\cite{raskin:2010}`</span></a> in which we do a
hydrostatic burn everywhere, but if we get a negative energy change,
the burning is redone in self-heating mode (the logic being that a
negative energy release corresponds to NSE conditions)</p>
</li>
<li><p class="first">burning_mode = 3 : suppressed burning</p>
<p>This does a self-heating burn, but limits all values of the RHS
by a factor <span class="math">\(L = \text{min}(1, f_s (e / \dot{e}) / t_s)\)</span>, such
that <span class="math">\(\dot{e} = f_s\, e / t_s\)</span>, where <span class="math">\(f_s\)</span> is a safety factor,
set via burning_mode_factor.</p>
</li>
</ul>
<p>When the integration is started, the burning mode is used to identify
whether temperature evolution should take place. This is used to
set the self_heat field in the burn_t type passed
into the RHS and Jacobian functions.</p>
<p>The evolution of the thermodynamic quantities (like specific heats and
other partial derivatives) can be frozen during the integration to
their initial values, updated for every RHS call, or something
in-between. Just before we call the network-specific RHS routine, we
update the thermodynamics of our state (by calling
update_thermodynamics) <a class="footnote-reference" href="#id32" id="id21">[2]</a> The thermodynamic quantity update depends on two runtime
parameters, call_eos_in_rhs and dT_crit:</p>
<ul>
<li><p class="first">call_eos_in_rhs = T:</p>
<p>We call the EOS just before every RHS evaluation, using <span class="math">\(\rho, T\)</span> as
inputs. Therefore, the thermodynamic quantities will always be
consistent with the input state.</p>
</li>
<li><p class="first">call_eos_in_rhs = F</p>
<p>Here we keep track of the temperature, <span class="math">\(T_\mathrm{old}\)</span>, at
which the EOS was last called (which may be the start of integration).</p>
<p>If</p>
<div class="math">
\[\frac{T - T_\mathrm{old}}{T} &gt; \mathtt{dT\_crit}\]</div>
<p>then we update the thermodynamics. We also compute <span class="math">\(d(c_v)/dT\)</span> and
<span class="math">\(d(c_p)/dT\)</span> via differencing with the old thermodynamic state and
store these in the integrator. If this inequality is not met, then
we don’t change the thermodynamics, but simply update the
composition terms in the EOS state, e.g., <span class="math">\(\bar{A}\)</span>.</p>
<p>We interpret dT_crit as the fractional change needed in the
temperature during a burn to trigger an EOS call that updates the
thermodynamic variables. Note that this is fully independent of
call_eos_in_rhs.</p>
</li>
</ul>
<p>A network is free to write their own righthand side for the
temperature evolution equation in its actual_rhs() routine.
But since this equation only really needs to know the instantaneous
energy generation rate, <span class="math">\(\dot{e}\)</span>, most networks use the helper
function, temperature_rhs (in
integration/temperature_integration.f90):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">temperature_rhs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="nb">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="p">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>This function assumes that state % ydot(net_ienuc) is already
filled and simply fills state % ydot(net_itemp) according to
the prescription below.</p>
<p>We need the specific heat, <span class="math">\(c_x\)</span>. Note that because we are evaluating
the temperature evolution independent of any hydrodynamics, we do not
incorporate any advective or <span class="math">\(pdV\)</span> terms in the evolution. Therefore,
for our approximation here, we need to decide which specific heat we
want—usually either the specific heat at constant pressure, <span class="math">\(c_p\)</span>,
or the specific heat at constant volume, <span class="math">\(c_v\)</span>. The EOS generally
will provide both of these specific heats; which one to use is a
choice the user needs to make based on the physics of their problem.
This is controlled by the parameter do_constant_volume_burn,
which will use <span class="math">\(c_v\)</span> if .true. and <span class="math">\(c_p\)</span> is .false.. See
<a href="#id22"><span class="problematic" id="id23">:raw-latex:`\cite{maestro:III}`</span></a> for a discussion of the temperature evolution
equation.</p>
<p>A fully accurate integration of Equation <a class="reference external" href="#eq:temp_integrate">[eq:temp_integrate]</a>
requires an evaluation of the specific heat at each integration step,
which involves an EOS call given the current temperature. This is done
if call_eos_in_rhs = T, as discussed above.
This may add significantly to the expense of the calculation,
especially for smaller networks where construction of the RHS is
inexpensive</p>
<p>For call_eos_in_rhs = F, we can still capture some evolution
of the specific heat by periodically calling the EOS (using
dT_crit as described above) and extrapolating to the current
temperature as:</p>
<div class="math">
\[c_x = (c_x)_0 + \frac{T - T_0}{d(c_x)/dT|_0}\]</div>
<p>where the ‘<span class="math">\(_0\)</span>’ quantities are the values from when the EOS was last
called. This represents a middle ground between fully on and fully
off.</p>
<p>Note: if state % self_heat = F, then we do not evolve
temperature.</p>
<p>The runtime parameter integrate_temperature can be used to
disable temperature evolution (by zeroing out
ydot(net_itemp)).</p>
<p>The last equation in our system is the nuclear energy release,
<span class="math">\(\edot\)</span>. Because of the operator-split approach to this ODE system,
this is not the true specific internal energy, <span class="math">\(e\)</span> (since it only
responds only to the nuclear energy release and no pdV work).</p>
<p>At initialization, <span class="math">\(e\)</span> is set to the value from the EOS consistent
with the initial temperature, density, and composition:</p>
<div class="math">
\[e_0 = e(\rho_0, T_0, {X_k}_0)\]</div>
<p>In the integration routines, this is termed the “energy offset”.</p>
<p>As the system is integrated, <span class="math">\(e\)</span> is updated to account for the
nuclear energy release,</p>
<div class="math">
\[e(t) = e_0 + \int_{t_0}^t f(\dot{Y}_k) dt\]</div>
<p>Note that thermodynamic consistency will no longer be maintained
(because density doesn’t evolve and the <span class="math">\(T\)</span> evolution is approximate)
but <span class="math">\(e\)</span> will represent an approximation to the current specific
internal energy, including the nuclear energy generation release.</p>
<p>Upon exit, we subtract off this initial offset, so % e in
the returned burn_t type from the actual_integrator
call represents the energy <em>release</em> during the burn.</p>
</div>
<div class="section" id="nspec-evolve-implementation">
<span id="ch-networks-nspec-evolve"></span><h3>nspec_evolve Implementation<a class="headerlink" href="#nspec-evolve-implementation" title="Permalink to this headline">¶</a></h3>
<p>For networks where nspec_evolve <span class="math">\(&lt;\)</span> nspec, it may be
necessary to reset the species mass fractions each time you enter the
RHS routine. As an example, the network ignition_chamulak has
3 species, <span class="math">\(^{12}\mathrm{C}\)</span>, <span class="math">\(^{16}\mathrm{O}\)</span>, and <span class="math">\(^{24}\mathrm{Mg}\)</span>. In this
network, <span class="math">\(^{16}\mathrm{O}\)</span> is not evolved at all and any change in
<span class="math">\(^{12}\mathrm{C}\)</span> is reflected in <span class="math">\(^{24}\mathrm{Mg}\)</span>. So we can evolve only the
equation for <span class="math">\(^{12}\mathrm{C}\)</span>. The algebraic relation between the
unevolved mass fractions that must be enforced then is:</p>
<div class="math">
\[X(\isotm{Mg}{24}) = 1 - X(\isotm{C}{12}) - X(\isotm{O}{16})\]</div>
<p>This is implemented in the routine update_unevolved_species:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">update_unevolved_species</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="nb">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="p">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>This needs to be explicitly called in actual_rhs before
the mass fractions from the input state are accessed. It is
also called directly by the integrator at the end of integration,
to make sure the final state is consistent.</p>
</div>
<div class="section" id="renormalization">
<h3>Renormalization<a class="headerlink" href="#renormalization" title="Permalink to this headline">¶</a></h3>
<p>The renormalize_abundances parameter controls whether we
renormalize the abundances so that the mass fractions sum to one
during a burn. This has the positive benefit that in some cases it can
prevent the integrator from going off to infinity or otherwise go
crazy; a possible negative benefit is that it may slow down
convergence because it interferes with the integration
scheme. Regardless of whether you enable this, we will always ensure
that the mass fractions stay positive and larger than some floor
small_x.</p>
</div>
</div>
<div class="section" id="tolerances">
<h2>Tolerances<a class="headerlink" href="#tolerances" title="Permalink to this headline">¶</a></h2>
<p>Tolerances dictate how accurate the ODE solver must be while solving
equations during a simulation.
Typically, the smaller the tolerance is, the more accurate the results will be.
However, if the tolerance is too small, the code may run for too long
or the ODE solver will never converge.
In these simulations,
rtol values will set the relative tolerances and
atol values will set the absolute tolerances for the ODE solver.
Often, one can find and set these values in an input file for a simulation.</p>
<p>Figure&nbsp;<a class="reference external" href="#fig:tolerances">[fig:tolerances]</a> shows the results of a simple simulation using the
burn_cell unit test to determine
what tolerances are ideal for simulations.
For this investigation, it was assumed that a run with a tolerance of <span class="math">\(10^{-12}\)</span>
corresponded to an exact result,
so it is used as the basis for the rest of the tests.
From the figure, one can infer that the <span class="math">\(10^{-3}\)</span> and <span class="math">\(10^{-6}\)</span> tolerances
do not yeild the most accurate results
because their relative error values are fairly large.
However, the test with a tolerance of <span class="math">\(10^{-9}\)</span> is accurate
and not so low that it takes incredible amounts of computer time,
so <span class="math">\(10^{-9}\)</span> should be used as the default tolerance in future simulations.</p>
</div>
<div class="section" id="stiff-ode-solvers">
<span id="ch-networks-integrators"></span><h2>Stiff ODE Solvers<a class="headerlink" href="#stiff-ode-solvers" title="Permalink to this headline">¶</a></h2>
<p>The integration tolerances for the burn are controlled by
<code class="docutils literal"><span class="pre">rtol_spec</span></code>, <code class="docutils literal"><span class="pre">rtol_enuc</span></code>, and <code class="docutils literal"><span class="pre">rtol_temp</span></code>,
which are the relative error tolerances for
Eqs.&nbsp;<a class="reference external" href="#eq:spec_integrate">[eq:spec_integrate]</a>, <a class="reference external" href="#eq:enuc_integrate">[eq:enuc_integrate]</a>, and
<a class="reference external" href="#eq:temp_integrate">[eq:temp_integrate]</a>, respectively. There are corresponding
<code class="docutils literal"><span class="pre">atol</span></code> parameters for the absolute error tolerances. Note that
not all integrators handle error tolerances the same way—see the
sections below for integrator-specific information.</p>
<p>We integrate our system using a stiff ordinary differential equation
integration solver. The absolute error tolerances are set by default
to <span class="math">\(10^{-12}\)</span> for the species, and a relative tolerance of <span class="math">\(10^{-6}\)</span>
is used for the temperature and energy. The integration yields the
new values of the mass fractions, <span class="math">\(Y_k^\outp\)</span>.</p>
<p>There are several options for integrators. Each should be capable of
evolving any of the networks, but varying in their approach. Internally,
the integrators uses different data structures to store the integration
progress (from the old-style rpar array in VODE to derived
types), and each integrator needs to provide a routine to convert
from the integrator’s internal representation to the burn_t
type required by the actual_rhs and actual_jac routine.</p>
<p>The name of the integrator can be selected at compile time using
the INTEGRATOR_DIR variable in the makefile. Presently,
the allowed options are BS, VBDF, and VODE.</p>
<div class="section" id="actual-integrator">
<h3>actual_integrator<a class="headerlink" href="#actual-integrator" title="Permalink to this headline">¶</a></h3>
<p>The entry point to the integrator is actual_integrator:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">actual_integrator</span><span class="p">(</span><span class="n">state_in</span><span class="p">,</span> <span class="n">state_out</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

  <span class="nb">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">),</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span>   <span class="p">)</span> <span class="p">::</span> <span class="n">state_in</span>
  <span class="nb">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">),</span> <span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">::</span> <span class="n">state_out</span>
  <span class="n">real</span><span class="p">(</span><span class="n">dp_t</span><span class="p">),</span>    <span class="n">intent</span><span class="p">(</span><span class="ow">in</span>   <span class="p">)</span> <span class="p">::</span> <span class="n">dt</span><span class="p">,</span> <span class="n">time</span>
</pre></div>
</div>
<p>A basic flow chart of this interface is as follows (note: there are
many conversions between eos_t, burn_t, and any
integrator-specific type implied in these operations):</p>
<ol class="arabic">
<li><p class="first">Call the EOS on the input state, using <span class="math">\(\rho, T\)</span> as the input
variables.</p>
<p>This involves:</p>
<ol class="arabic simple">
<li>calling burn_to_eos to produce an eos_t
with the thermodynamic information.</li>
<li>calling the EOS</li>
<li>calling eos_to_XX, where XX is, e.g.
bs, the integrator type. This copies all of the relevant
data into the internal representation used by the integrator.</li>
</ol>
<p>We use the EOS result to define the energy offset for <span class="math">\(e\)</span>
integration.</p>
</li>
<li><p class="first">Compute the initial <span class="math">\(d(c_x)/dT\)</span> derivatives, if necessary, by
finite differencing on the temperature.</p>
</li>
<li><p class="first">Call the main integration routine to advance the inputs state
through the desired time interval, producing the new, output
state.</p>
</li>
<li><p class="first">If necessary (integration failure, burn_mode demands)
do any retries of the integration</p>
</li>
<li><p class="first">Subtract off the energy offset—we now store just the
energy release as state_out % e</p>
</li>
<li><p class="first">Convert back to a burn_t type (by calling XX_to_burn).</p>
</li>
<li><p class="first">update any unevolved species, for nspec_evolve <span class="math">\(&lt;\)</span>
nspec</p>
</li>
<li><p class="first">normalize the abundances so they sum to 1</p>
</li>
</ol>
</div>
<div class="section" id="righthand-side-wrapper">
<h3>Righthand side wrapper<a class="headerlink" href="#righthand-side-wrapper" title="Permalink to this headline">¶</a></h3>
<p>Each integrator does their own thing to construct the solution,
but they will all need to assess the RHS in actual_rhs,
which means converting from their internal representation
to the burn_t type. This is handled in a file
called XX_rhs.f90, where XX is the integrator name.
The basic outline of this routine is:</p>
<ol class="arabic">
<li><p class="first">call clean_state</p>
<p>This function operates on the ODE integrator vector directly
(accessing it from the integrator’s internal data structure). It
makes sure that the mass fractions lie between <span class="math">\([10^{-30}, 1]\)</span> and
that the temperature lies between <span class="math">\([{\tt small\_temp}, 10^{11}]\)</span>. The
latter upper limit is arbitrary, but is safe for the types of problems
we support with these networks.</p>
</li>
<li><p class="first">renormalize the species, if renormalize_abundances = T</p>
</li>
<li><p class="first">update the thermodynamic quantities if we are doing
call_eos_in_rhs or the dT_crit requires</p>
</li>
<li><p class="first">convert to a burn_t type and call the actual RHS</p>
</li>
<li><p class="first">convert derives to mass-fraction-based (if
integrate_molar_fraction = F and zero out the temperature or
energy derivatives (if integrate_temperature = F or
integrate_energy = F, respectively).</p>
</li>
<li><p class="first">limit the rates if burning_mode = 3</p>
</li>
<li><p class="first">convert back to the integrator’s internal representation</p>
</li>
</ol>
</div>
<div class="section" id="bs">
<span id="sec-bs"></span><h3>BS<a class="headerlink" href="#bs" title="Permalink to this headline">¶</a></h3>
<p>This integrator is based on the stiff-ODE methods from <a href="#id24"><span class="problematic" id="id25">:raw-latex:`\cite{NR}`</span></a>, but
written with reaction network integration in mind (so it knows about
species), and in a modular / threadsafe fashion to work with our data
structures. This integrator appears quite robust.</p>
<div class="section" id="bs-t-data-structure">
<h4>bs_t data structure.<a class="headerlink" href="#bs-t-data-structure" title="Permalink to this headline">¶</a></h4>
<p>The bs_t type is the main data structure for the BS integrator.
This holds the integration variables (as y(1:neqs)) and data
associated with the timestepping. It also holds a burn_t type
as bs_t % burn_s. This component is used to interface with
the networks. The conversion routines bs_to_burn and
burn_to_bs simply sync up bs_t % y(:) and bs_t %
burn_s.</p>
<p>The upar(:) component contains the meta-data that is not held in
the burn_t but nevertheless is associate with the current
state. This is an array that can be indexed via the integers define
in the rpar_indices module. Note that because the bs_t
contains its own burn_t type, the BS integrator does not need
as much meta-data as some other integrators. The fields of upar
are:</p>
<ul>
<li><p class="first">bs_t % upar(irp_nspec : irp_nspec-1+n_not_evolved)</p>
<p>These are the mass fractions of the nspec - nspec_evolve
species that are not evolved in the ODE system.</p>
</li>
<li><p class="first">bs_t % upar(irp_y_init : irp_y_init-1+neqs)</p>
<p>This is the initial values of the ODE integration vector.</p>
</li>
<li><p class="first">bs_t % upar(irp_t_sound)</p>
<p>This is the sound-crossing time for a zone.</p>
</li>
<li><p class="first">bs_t % upar(irp_t0)</p>
<p>This is the simulation time at the start of integration. This can
be used as an offset to convert between simulation time and
integration time (we always start the integration at <span class="math">\(t = 0\)</span>).</p>
</li>
</ul>
</div>
<div class="section" id="error-criteria">
<h4>Error criteria.<a class="headerlink" href="#error-criteria" title="Permalink to this headline">¶</a></h4>
<p>There is a single relative tolerance used
for all ODEs, instead of a separate one for species, temperature, and
energy, it is simply the maximum of {rtol_spec,
rtol_temp, rtol_enuc}. The absolute tolerance parameters
are ignored.</p>
<p>A relative tolerance needs a metric against which to compare. BS
has two options, chosen by the runtime parameter scaling_method.
Considering a vector <span class="math">\({\bf y} = (Y_k, e, T)^\intercal\)</span>, the scales
to compare against, <span class="math">\({\bf y}_\mathrm{scal}\)</span>, are:</p>
<ul>
<li><p class="first">scaling_method = 1 :</p>
<div class="math">
\[{\bf y}_\mathrm{scal} = |{\bf y}| + \Delta t  |\dot{\bf y}| + \epsilon\]</div>
<p>This is an extrapolation of <span class="math">\({\bf y}\)</span> in time. The quantity
<span class="math">\(\epsilon\)</span> is a small number (hardcoded to <span class="math">\(10^{-30}\)</span>) to prevent any
scale from being zero.</p>
</li>
<li><p class="first">scaling_method = 2 :</p>
<div class="math">
\[({y}_\mathrm{scal})_j = \max \left (|y_j|, \mathtt{ode\_scale\_floor} \right )\]</div>
<p>for <span class="math">\(j = 1, \ldots, {\tt neq}\)</span>. Here, ode_scale_floor is a runtime
parameter that sets a lower-limit to the scaling for each variable in the
vector <span class="math">\({\bf y}_\mathrm{scal}\)</span>. The default value is currently <span class="math">\(10^{-6}\)</span>
(although any network can override this using priorities). The effect of
this scaling is that species with an abundance <span class="math">\(\ll\)</span> ode_scal_floor
will not be used as strongly in assessing the accuracy of a step.</p>
</li>
</ul>
<p>These correspond to the options presented in <a href="#id26"><span class="problematic" id="id27">:raw-latex:`\cite{NR}`</span></a>.</p>
<p>A final option, use_timestep_estimator enables the
timestep estimator from VODE to determine a good starting
timestep for integration.</p>
</div>
</div>
<div class="section" id="vode">
<span id="sec-vode"></span><h3>VODE<a class="headerlink" href="#vode" title="Permalink to this headline">¶</a></h3>
<p>VODE is a classic integration package described in <a href="#id28"><span class="problematic" id="id29">:raw-latex:`\cite{vode}`</span></a>. We
use the implicit integration method in the package.</p>
<div class="section" id="data-structures">
<h4>data structures.<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h4>
<p>VODE does not allow for derived types
for its internal representation and instead simply uses a solution
vector, y(neqs), and an array of parameters, rpar(:). The
indices into rpar are defined in the rpar_indices module.</p>
</div>
<div class="section" id="id30">
<h4>tolerances.<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<p>Our copy of VODE is made threadsafe by use of the OpenMP
threadprivate directive on Fortran common blocks. However, due to
the use of computed go tos, we have not ported it to GPUs using
OpenACC.</p>
</div>
</div>
<div class="section" id="vbdf">
<span id="sec-vbdf"></span><h3>VBDF<a class="headerlink" href="#vbdf" title="Permalink to this headline">¶</a></h3>
<p>VBDF is a modern implementation of the methods in VODE, written by
Matt Emmett. It supports integrating a vector of states, but we do
not use that capability.</p>
<p>The error criteria is the same as VODE—separate relative, rtol,
and absolute, atol, error tolerances are specified for each
variable that is being integrated. A weight is constructed as:</p>
<div class="math">
\[W_m = \frac{1}{{\tt rtol}_m |y_m| + {\tt atol}_m}\]</div>
<p>where needed, the error, <span class="math">\(\epsilon\)</span>, is constructed by computing an <span class="math">\(L_2\)</span>
norm:</p>
<div class="math">
\[\epsilon = \left [ \frac{1}{N} \sum_m (y_m W_m)^2 \right ]^{1/2}\]</div>
<p>where <span class="math">\(m = 1, \ldots, N\)</span> indexes the ODE solution vector. With this
weighting, <span class="math">\(\epsilon &lt; 1\)</span> means we’ve achieved our desired accuracy.</p>
</div>
<div class="section" id="retries">
<h3>Retries<a class="headerlink" href="#retries" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="overriding-parameter-defaults-on-a-network-by-network-basis">
<h2>Overriding Parameter Defaults on a Network-by-Network Basis<a class="headerlink" href="#overriding-parameter-defaults-on-a-network-by-network-basis" title="Permalink to this headline">¶</a></h2>
<p>Any network can override or add to any of the existing runtime
parameters by creating a _parameters file in the network
directory (e.g.,
networks/triple_alpha_plus_cago/_parameters). As noted in
Chapter [chapter:parameters], the fourth column in the
_parameter file definition is the <em>priority</em>. When a
duplicate parameter is encountered by the scripts writing the
extern_probin_module, the value of the parameter with the highest
priority is used. So picking a large integer value for the priority
in a network’s _parameter file will ensure that it takes
precedence.</p>
<p><img alt="image" src="doxygen_network" /></p>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[1]</a></td><td>Note that in previous versions of our networks in
CASTRO&nbsp;and MAESTRO, there was another term in the temperature
equation relating to the chemical potential of the gas as it came
from the EOS. We have since decided that this term should
analytically cancel to zero in all cases for our nuclear networks,
and so we no longer think it is correct to include a numerical
approximation of it in the integration scheme. So the current
results given by our networks will in general be a little different
than in the past.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[2]</a></td><td>Note: each integrator provides its
own implementation of this, since it operates on the internal
data-structure of the integrator, but the basic procedure is the
same.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="transport.html" class="btn btn-neutral float-right" title="Transport Coefficients" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="eos.html" class="btn btn-neutral" title="Equations of State" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, StarKiller Development Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'18.10',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="_static/mathjax_conf.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>