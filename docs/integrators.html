

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Integrating a Network &mdash; StarKiller Microphysics  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"rhozero": "{\\rho_0}", "pizero": "{\\pi_0}", "pizeroone": "{\\pi_0^{(1)}}", "pizerotwo": "{\\pi_0^{(2)}}", "gammabar": "{\\overline{\\Gamma}_1}", "ptl": "{{\\partial}}", "eb": "{{\\bf e}}", "fb": "{{\\bf f}}", "ib": "{{\\bf i}}", "Ub": "{{\\bf U}}", "Vb": "{{\\bf V}}", "xb": "{{\\bf x}}", "ut": "{\\tilde{u}}", "vt": "{\\tilde{v}}", "wt": "{\\tilde{w}}", "Ubt": "{\\widetilde{\\Ub}}", "edge": "{\\rm EDGE}", "mac": "{\\rm MAC}", "trans": "{\\rm TRANS}", "nablab": "{\\mathbf{\\nabla}}", "cdotb": "{\\mathbf{\\cdot}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\frac{1}{2}}", "nph": "{{n + \\myhalf}}", "nmh": "{{n - \\myhalf}}", "Hext": "{{H_{\\rm ext}}}", "Hnuc": "{{H_{\\rm nuc}}}", "kth": "{k_{\\rm th}}", "pred": "{{\\rm pred}}", "Sbar": "{\\overline{S}}", "inp": "{\\mathrm{in}}", "initp": "{\\mathrm{init}}", "outp": "{\\mathrm{out}}", "uadv": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV}}}", "uadvone": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV},\\star}}", "uadvonedag": "{\\Ubt^{\\mathrm{ADV},\\dagger,\\star}}", "uadvtwo": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV}}}", "uadvtwodag": "{\\Ubt^{\\mathrm{ADV},\\dagger}}", "uadvsdcstar": "{\\mathbf{U}^{\\mathrm{ADV},\\star}}", "uadvsdcpred": "{\\mathbf{U}^{\\mathrm{ADV},\\mathrm{pred}}}", "uadvsdc": "{\\mathbf{U}^{\\mathrm{ADV}}}", "dt": "{\\Delta t}", "dr": "{\\Delta r}", "etarho": "{\\eta_{\\rho}}", "etarhoec": "{\\etarho^{\\rm ec}}", "etarhocc": "{\\etarho^{\\rm cc}}", "etarhoflux": "{\\etarho^{\\rm flux}}", "divetarho": "{\\nabla\\cdot(\\etarho\\eb_r)}", "ow": "{\\overline{w}_0}", "dw": "{\\delta w_0}", "thalf": "{\\sfrac{3}{2}}", "rhop": "{{\\rho^{\\prime}}}", "omegadot": "{\\dot{\\omega}}", "er": "{\\mathbf{e}_r}", "ex": "{\\mathbf{e}_x}", "ey": "{\\mathbf{e}_y}", "ez": "{\\mathbf{e}_z}", "Omegab": "{{\\bf \\Omega}}", "rb": "{{\\bf r}}", "isotm": ["{{}^{#2}\\mathrm{#1}}", 2], "edot": "{{{\\dot{e}_\\mathrm{nuc}}}}", "enuc": "{{{{e}_\\mathrm{nuc}}}}", "edotnu": "{{{\\dot{e}_\\nu}}}", "rt": "{\\tilde{r}_0}", "rhob": "{\\ensuremath{\\rho_\\mathrm{base}}}", "Tb": "{\\ensuremath{T_\\mathrm{base}}}", "gcc": "{\\mathrm{g~cm^{-3} }}", "pb": "{p_\\mathrm{base}}", "qburn": "{q_\\mathrm{burn}}", "Uc": "{{\\boldsymbol{\\mathcal{U}}}}", "Fb": "{\\mathbf{F}}", "Sc": "{\\mathbf{S}}", "Shydro": "{{{\\bf S}^{\\mathrm{hydro}}}}", "Rb": "{{\\bf R}}", "Rq": "{{\\bf R}}", "Adv": ["{{\\left [\\boldsymbol{\\mathcal{A}} \\left(#1\\right)\\right]}}", 1], "Advs": ["{{\\boldsymbol{\\mathcal{A}} \\left(#1\\right)}}", 1], "Sdot": "{\\dot{S}}"}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Transport Coefficients" href="transport.html" />
    <link rel="prev" title="Reaction Networks" href="networks.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          


          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> StarKiller Microphysics
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
    <div class="branch">
        Branch: <a href="./integrators.html">main</a> | <a href="./dev/integrators.html">development</a>
    </div>

        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">StarKiller basics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">StarKiller Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="eos.html">Equations of State</a></li>
<li class="toctree-l1"><a class="reference internal" href="networks.html">Reaction Networks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Integrating a Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#reaction-ode-system">Reaction ODE System</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interfaces">Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fortran">Fortran</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c">C++</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#thermodynamics-and-t-evolution">Thermodynamics and <span class="math notranslate nohighlight">\(T\)</span> Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#burning-mode">Burning Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eos-calls">EOS Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#t-evolution"><span class="math notranslate nohighlight">\(T\)</span> Evolution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#energy-integration">Energy Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#renormalization">Renormalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stiff-ode-solvers">Stiff ODE Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tolerances">Tolerances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fortran-interfaces">Fortran interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#integrator"><code class="docutils literal notranslate"><span class="pre">integrator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#righthand-side-wrapper">Righthand side wrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="#jacobian-wrapper">Jacobian wrapper</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-interfaces">C++ interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#burner"><code class="docutils literal notranslate"><span class="pre">burner</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#sec-bs">Righthand side wrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">Jacobian wrapper</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bs">BS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bs-t-data-structure">bs_t data structure.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-criteria">Error criteria.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#retries">Retries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overriding-parameter-defaults-on-a-network-by-network-basis">Overriding Parameter Defaults on a Network-by-Network Basis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="transport.html">Transport Coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="cxx.html">C++ interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="unit_tests.html">Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">StarKiller Microphysics</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Integrating a Network</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/integrators.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="integrating-a-network">
<h1>Integrating a Network<a class="headerlink" href="#integrating-a-network" title="Permalink to this headline">¶</a></h1>
<div class="section" id="reaction-ode-system">
<h2>Reaction ODE System<a class="headerlink" href="#reaction-ode-system" title="Permalink to this headline">¶</a></h2>
<p>The equations we integrate to do a nuclear burn are:</p>
<div class="math notranslate nohighlight" id="equation-eq-spec-integrate">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-spec-integrate" title="Permalink to this equation">¶</a></span>\[\frac{dX_k}{dt} = \omegadot_k(\rho,X_k,T)\]</div>
<div class="math notranslate nohighlight" id="equation-eq-enuc-integrate">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-enuc-integrate" title="Permalink to this equation">¶</a></span>\[\frac{d\enuc}{dt} = f(\dot{X}_k)\]</div>
<div class="math notranslate nohighlight" id="equation-eq-temp-integrate">
<span class="eqno">(3)<a class="headerlink" href="#equation-eq-temp-integrate" title="Permalink to this equation">¶</a></span>\[\frac{dT}{dt} =\frac{\edot}{c_x} .\]</div>
<p>Here, <span class="math notranslate nohighlight">\(X_k\)</span> is the mass fraction of species <span class="math notranslate nohighlight">\(k\)</span>, <span class="math notranslate nohighlight">\(\enuc\)</span> is the specifc
nuclear energy created through reactions, <span class="math notranslate nohighlight">\(T\)</span> is the
temperature <a class="footnote-reference brackets" href="#id10" id="id1">1</a> , and <span class="math notranslate nohighlight">\(c_x\)</span> is the specific heat for the
fluid. The function <span class="math notranslate nohighlight">\(f\)</span> provides the energy release based on the
instantaneous reaction terms, <span class="math notranslate nohighlight">\(\dot{X}_k\)</span>. As noted in the previous
section, this is implemented in a network-specific manner.</p>
<p>In this system, <span class="math notranslate nohighlight">\(\enuc\)</span> is not necessarily the total specific internal
energy, but rather captures the energy release during the burn:</p>
<div class="math notranslate nohighlight">
\[\enuc = \int \edot dt\]</div>
<p>so we know how much energy was released (or required) over the burn.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the energy release that is used in computing the final
energy generation rate for the burning.  By integrating a separate
equation for <span class="math notranslate nohighlight">\(\enuc\)</span>, we can account for neutrino losses as
well as the energy release from the changing binding energy of the
fusion products.</p>
</div>
<p>While this is the most common way to construct the set of
burn equations, and is used in most of our production networks,
all of them are ultimately implemented by the network itself, which
can choose to disable the evolution of any of these equations by
setting the RHS to zero. The integration software provides some
helper routines that construct common RHS evaluations, like the RHS
of the temperature equation given <span class="math notranslate nohighlight">\(\dot{e}\)</span>, but these calls
are always explicitly done by the individual networks rather than
being handled by the integration backend. This allows you to write a
new network that defines the RHS in whatever way you like.</p>
</div>
<div class="section" id="interfaces">
<h2>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h2>
<p>There are both C++ and Fortran interfaces to all of the networks and
integrators.  For the most part, they implement similar data
structures to describe the evolution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>StarKiller integrates the reaction system in terms of mass fractions,
<span class="math notranslate nohighlight">\(X_k\)</span>, but most astrophysical networks use molar fractions,
<span class="math notranslate nohighlight">\(Y_k\)</span>.  As a result, we expect the networks to return the
righthand side and Jacobians in terms of molar fractions.  The StarKiller
routines will internally convert to mass fractions as needed for the
integrators.</p>
</div>
<div class="section" id="fortran">
<h3>Fortran<a class="headerlink" href="#fortran" title="Permalink to this headline">¶</a></h3>
<p>The righthand side of the network is implemented by
<code class="docutils literal notranslate"><span class="pre">actual_rhs()</span></code> in <code class="docutils literal notranslate"><span class="pre">actual_rhs.f90</span></code>, and appears as</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">actual_rhs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="k">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>All of the necessary integration data comes in through state, as:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">xn(:)</span></code> : the <code class="docutils literal notranslate"><span class="pre">nspec</span></code> mass fractions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">aux(:)</span></code> : the <code class="docutils literal notranslate"><span class="pre">naux</span></code> auxillary data (only available if <code class="docutils literal notranslate"><span class="pre">NAUX_NET</span></code> &gt; 0)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">e</span></code> : the current value of the ODE system’s energy
release, <span class="math notranslate nohighlight">\(\enuc\)</span>—note: as discussed above, this is not
necessarily the energy you would get by calling the EOS on the
state. It is very rare (never?) that a RHS implementation would need
to use this variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">T</span></code> : the current temperature</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">rho</span></code> : the current density</p></li>
</ul>
<p>Note that we come in with the mass fractions, but the molar fractions can
be computed as:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">double precision</span> <span class="kd">::</span> <span class="n">y</span><span class="p">(</span><span class="n">nspec</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">y</span><span class="p">(:)</span> <span class="o">=</span> <span class="n">state</span> <span class="p">%</span> <span class="n">xn</span><span class="p">(:)</span> <span class="o">*</span> <span class="n">aion_inv</span><span class="p">(:)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">actual_rhs()</span></code> routine’s job is to fill the righthand side vector
for the ODE system, <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">ydot(:)</span></code>. Here, the important
fields to fill are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">ydot(1:nspec)</span></code> : the change in <em>molar
fractions</em> for the <code class="docutils literal notranslate"><span class="pre">nspec</span></code> species that we are evolving,
<span class="math notranslate nohighlight">\(d({Y}_k)/dt\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">ydot(net_ienuc)</span></code> : the change in the energy release
from the net, <span class="math notranslate nohighlight">\(d\enuc/dt\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">ydot(net_itemp)</span></code> : the change in temperature, <span class="math notranslate nohighlight">\(dT/dt\)</span></p></li>
</ul>
<p>The righthand side routine is assumed to return the change in <em>molar fractions</em>,
<span class="math notranslate nohighlight">\(dY_k/dt\)</span>. These will be converted to the change in mass fractions, <span class="math notranslate nohighlight">\(dX_k/dt\)</span>
by the wrappers that call the righthand side routine for the integrator.
If the network builds the RHS in terms of mass fractions directly, <span class="math notranslate nohighlight">\(dX_k/dt\)</span>, then
these will need to be converted to molar fraction rates for storage, e.g.,
<span class="math notranslate nohighlight">\(dY_k/dt = A_k^{-1} dX_k/dt\)</span>.</p>
<p>The Jacobian is provided by actual_jac(state), and takes the
form:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">actual_jac</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="k">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>The Jacobian matrix elements are stored in <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac</span></code> as:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(m,</span> <span class="pre">n)</span></code> for <span class="math notranslate nohighlight">\(\mathrm{m}, \mathrm{n} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math notranslate nohighlight">\(d(\dot{Y}_m)/dY_n\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(net_ienuc,</span> <span class="pre">n)</span></code> for <span class="math notranslate nohighlight">\(\mathrm{n} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math notranslate nohighlight">\(d(\edot)/dY_n\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(net_itemp,</span> <span class="pre">n)</span></code> for <span class="math notranslate nohighlight">\(\mathrm{n} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math notranslate nohighlight">\(d(\dot{T})/dY_n\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(m,</span> <span class="pre">net_itemp)</span></code> for <span class="math notranslate nohighlight">\(\mathrm{m} \in [1, \mathrm{nspec\_evolve}]\)</span> :
<span class="math notranslate nohighlight">\(d(\dot{Y}_m)/dT\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(net_ienuc,</span> <span class="pre">net_itemp)</span></code> :
<span class="math notranslate nohighlight">\(d(\edot)/dT\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(net_itemp,</span> <span class="pre">net_itemp)</span></code> :
<span class="math notranslate nohighlight">\(d(\dot{T})/dT\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">jac(p,</span> <span class="pre">net_ienuc)</span></code> <span class="math notranslate nohighlight">\(= 0\)</span> for <span class="math notranslate nohighlight">\(\mathrm{p} \in [1, \mathrm{neqs}]\)</span>, since nothing
should depend on the integrated energy release</p></li>
</ul>
<p>The form looks like:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left (
\begin{matrix}
   \ddots  &amp; \vdots                          &amp;          &amp; \vdots &amp; \vdots \\
   \cdots  &amp; \partial \dot{Y}_m/\partial Y_n &amp; \cdots   &amp; 0      &amp; \partial \dot{Y}_m/\partial T    \\
           &amp; \vdots                          &amp; \ddots   &amp; \vdots &amp; \vdots  \\
   \cdots  &amp; \partial \edot/\partial Y_n     &amp; \cdots   &amp; 0      &amp; \partial \edot/\partial T   \\
   \cdots  &amp; \partial \dot{T}/\partial Y_n   &amp; \cdots   &amp; 0      &amp; \partial \dot{T}/\partial T   \\
\end{matrix}
\right )\end{split}\]</div>
<p>This shows that all of the derivatives with respect to the nuclear
energy generated, <span class="math notranslate nohighlight">\(e_\mathrm{nuc}\)</span> are zero. Again, this is because
this is just a diagnostic variable.</p>
<p>Note: a network is not required to compute a Jacobian if a numerical
Jacobian is used. This is set with the runtime parameter
<code class="docutils literal notranslate"><span class="pre">jacobian</span></code> = 2, and implemented in
<code class="docutils literal notranslate"><span class="pre">integration/numerical_jacobian.f90</span></code> using finite-differences.</p>
</div>
<div class="section" id="c">
<h3>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only the VODE solver supports C++, so the interfaces
here are specific to that integrator.</p>
</div>
<p>The righthand side implementation of the network has the interface:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMREX_GPU_HOST_DEVICE</span> <span class="n">AMREX_FORCE_INLINE</span>
<span class="kt">void</span> <span class="n">actual_rhs</span><span class="p">(</span><span class="n">burn_t</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span> <span class="n">Array1D</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">neqs</span><span class="o">&gt;&amp;</span> <span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the C++ implementation of the integrator, we use 1-based
indexing for <code class="docutils literal notranslate"><span class="pre">ydot</span></code> to allow for easier conversion between
Fortran and C++ networks.</p>
</div>
<p>The Jacobian has the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">MatrixType</span><span class="o">&gt;</span>
<span class="n">AMREX_GPU_HOST_DEVICE</span> <span class="n">AMREX_FORCE_INLINE</span>
<span class="kt">void</span> <span class="n">actual_jac</span><span class="p">(</span><span class="n">burn_t</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span> <span class="n">MatrixType</span><span class="o">&amp;</span> <span class="n">jac</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">MatrixType</span></code> is either a <code class="docutils literal notranslate"><span class="pre">SparseMatrix</span></code> type or a
<code class="docutils literal notranslate"><span class="pre">RArray2D</span></code> type (set in the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> type in <code class="docutils literal notranslate"><span class="pre">vode_type.H</span></code>.
This allows a network to use either sparse or dense linear algebra.
In the case of dense linear algebra, <code class="docutils literal notranslate"><span class="pre">RArray2D</span></code> is essentially a 2-d
array indexed from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">VODE_NEQS</span></code> in each dimension.</p>
</div>
</div>
<div class="section" id="thermodynamics-and-t-evolution">
<h2>Thermodynamics and <span class="math notranslate nohighlight">\(T\)</span> Evolution<a class="headerlink" href="#thermodynamics-and-t-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="burning-mode">
<h3>Burning Mode<a class="headerlink" href="#burning-mode" title="Permalink to this headline">¶</a></h3>
<p>There are several different modes under which the burning can be done, set
via the burning_mode runtime parameter:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">burning_mode</span></code> = 0 : hydrostatic burning</p>
<p><span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(T\)</span> remain constant</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">burning_mode</span> <span class="pre">=</span> <span class="pre">1</span></code> : self-heating burn</p>
<p><span class="math notranslate nohighlight">\(T\)</span> evolves with the burning according to the temperature
evolution equation. This is the “usual” way of thinking of the
burning—all three equations (<a class="reference internal" href="#equation-eq-spec-integrate">(1)</a>,
<a class="reference internal" href="#equation-eq-enuc-integrate">(2)</a>, and <a class="reference internal" href="#equation-eq-temp-integrate">(3)</a>) are solved
simultaneously.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">burning_mode</span> <span class="pre">=</span> <span class="pre">2</span></code> : hybrid approach</p>
<p>This implements an approach from <a class="bibtex reference internal" href="zreferences.html#raskin-2010" id="id2">[RaskinScannapiecoRockefeller+10]</a> in which we do
a hydrostatic burn everywhere, but if we get a negative energy
change, the burning is redone in self-heating mode (the logic being
that a negative energy release corresponds to NSE conditions)</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">burning_mode</span> <span class="pre">=</span> <span class="pre">3</span></code> : suppressed burning</p>
<p>This does a self-heating burn, but limits all values of the RHS by a
factor <span class="math notranslate nohighlight">\(L = \text{min}(1, f_s (e / \dot{e}) / t_s)\)</span>, such that
<span class="math notranslate nohighlight">\(\dot{e} = f_s\, e / t_s\)</span>, where <span class="math notranslate nohighlight">\(f_s\)</span> is a safety
factor, set via burning_mode_factor.</p>
</li>
</ul>
<p>When the integration is started, the burning mode is used to identify
whether temperature evolution should take place. This is used to
set the self_heat field in the burn_t type passed
into the RHS and Jacobian functions.</p>
</div>
<div class="section" id="eos-calls">
<h3>EOS Calls<a class="headerlink" href="#eos-calls" title="Permalink to this headline">¶</a></h3>
<p>The evolution of the thermodynamic quantities (like specific heats and
other partial derivatives) can be frozen during the integration to
their initial values, updated for every RHS call, or something
in-between. Just before we call the network-specific RHS routine, we
update the thermodynamics of our state (by calling
<code class="docutils literal notranslate"><span class="pre">update_thermodynamics</span></code>) <a class="footnote-reference brackets" href="#id11" id="id3">2</a> The thermodynamic quantity update depends on two runtime
parameters, call_eos_in_rhs and dT_crit:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">call_eos_in_rhs</span> <span class="pre">=</span> <span class="pre">T</span></code>:</p>
<p>We call the EOS just before every RHS evaluation, using <span class="math notranslate nohighlight">\(\rho,
T\)</span> as inputs. Therefore, the thermodynamic quantities will always be
consistent with the input state.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">call_eos_in_rhs</span> <span class="pre">=</span> <span class="pre">F</span></code></p>
<p>Here we keep track of the temperature, <span class="math notranslate nohighlight">\(T_\mathrm{old}\)</span>, at
which the EOS was last called (which may be the start of
integration).</p>
<p>If</p>
<div class="math notranslate nohighlight">
\[\frac{T - T_\mathrm{old}}{T} &gt; \mathtt{dT\_crit}\]</div>
<p>then we update the thermodynamics. We also compute <span class="math notranslate nohighlight">\(d(c_v)/dT\)</span>
and <span class="math notranslate nohighlight">\(d(c_p)/dT\)</span> via differencing with the old thermodynamic
state and store these in the integrator. If this inequality is not
met, then we don’t change the thermodynamics, but simply update the
composition terms in the EOS state, e.g., <span class="math notranslate nohighlight">\(\bar{A}\)</span>.</p>
<p>We interpret <code class="docutils literal notranslate"><span class="pre">dT_crit</span></code> as the fractional change needed in the
temperature during a burn to trigger an EOS call that updates the
thermodynamic variables. Note that this is fully independent of
<code class="docutils literal notranslate"><span class="pre">call_eos_in_rhs</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="t-evolution">
<h3><span class="math notranslate nohighlight">\(T\)</span> Evolution<a class="headerlink" href="#t-evolution" title="Permalink to this headline">¶</a></h3>
<p>A network is free to write their own righthand side for the
temperature evolution equation in its <code class="docutils literal notranslate"><span class="pre">actual_rhs()</span></code> routine.
But since this equation only really needs to know the instantaneous
energy generation rate, <span class="math notranslate nohighlight">\(\dot{e}\)</span>, most networks use the helper
function, <code class="docutils literal notranslate"><span class="pre">temperature_rhs</span></code>.  The Fortran implementation is in
<code class="docutils literal notranslate"><span class="pre">integration/utils/temperature_integration.f90</span></code>:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">temperature_rhs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
  <span class="k">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span>
</pre></div>
</div>
<p>This function assumes that <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">ydot(net_ienuc)</span></code> is already
filled and simply fills <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">ydot(net_itemp)</span></code> according to
the prescription below.</p>
<p>The C++ implementation is in <code class="docutils literal notranslate"><span class="pre">integration/utils/temperature_integration.H</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMREX_GPU_HOST_DEVICE</span> <span class="n">AMREX_FORCE_INLINE</span>
<span class="kt">void</span> <span class="n">temperature_rhs</span> <span class="p">(</span><span class="n">burn_t</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span> <span class="n">Array1D</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">neqs</span><span class="o">&gt;&amp;</span> <span class="n">ydot</span><span class="p">)</span>
</pre></div>
</div>
<p>We need the specific heat, <span class="math notranslate nohighlight">\(c_x\)</span>. Note that because we are evaluating
the temperature evolution independent of any hydrodynamics, we do not
incorporate any advective or <span class="math notranslate nohighlight">\(pdV\)</span> terms in the evolution. Therefore,
for our approximation here, we need to decide which specific heat we
want—usually either the specific heat at constant pressure, <span class="math notranslate nohighlight">\(c_p\)</span>,
or the specific heat at constant volume, <span class="math notranslate nohighlight">\(c_v\)</span>. The EOS generally
will provide both of these specific heats; which one to use is a
choice the user needs to make based on the physics of their problem.
This is controlled by the parameter <code class="docutils literal notranslate"><span class="pre">do_constant_volume_burn</span></code>,
which will use <span class="math notranslate nohighlight">\(c_v\)</span> if <code class="docutils literal notranslate"><span class="pre">.true.</span></code> and <span class="math notranslate nohighlight">\(c_p\)</span> is <code class="docutils literal notranslate"><span class="pre">.false.</span></code>. See
<a class="bibtex reference internal" href="zreferences.html#maestro-iii" id="id4">[AlmgrenBellNonakaZingale08]</a> for a discussion of the temperature evolution
equation.</p>
<p>A fully accurate integration of Equation <a class="reference internal" href="#equation-eq-temp-integrate">(3)</a>
requires an evaluation of the specific heat at each integration step,
which involves an EOS call given the current temperature. This is done
if <code class="docutils literal notranslate"><span class="pre">call_eos_in_rhs</span> <span class="pre">=</span> <span class="pre">T</span></code>, as discussed above.
This may add significantly to the expense of the calculation,
especially for smaller networks where construction of the RHS is
inexpensive</p>
<p>For <code class="docutils literal notranslate"><span class="pre">call_eos_in_rhs</span> <span class="pre">=</span> <span class="pre">F</span></code>, we can still capture some evolution
of the specific heat by periodically calling the EOS (using
<code class="docutils literal notranslate"><span class="pre">dT_crit</span></code> as described above) and extrapolating to the current
temperature as:</p>
<div class="math notranslate nohighlight">
\[c_x = (c_x)_0 + \frac{T - T_0}{d(c_x)/dT|_0}\]</div>
<p>where the ‘<span class="math notranslate nohighlight">\(_0\)</span>’ quantities are the values from when the EOS was last
called. This represents a middle ground between fully on and fully
off.</p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">%</span> <span class="pre">self_heat</span> <span class="pre">=</span> <span class="pre">F</span></code> (Fortran) or <code class="docutils literal notranslate"><span class="pre">state.self_heat</span> <span class="pre">=</span>
<span class="pre">false</span></code> (C++), then we do not evolve temperature.</p>
<p>The runtime parameter <code class="docutils literal notranslate"><span class="pre">integrate_temperature</span></code> can be used to disable
temperature evolution (by zeroing out <code class="docutils literal notranslate"><span class="pre">ydot(net_itemp)</span></code>).</p>
</div>
</div>
<div class="section" id="energy-integration">
<h2>Energy Integration<a class="headerlink" href="#energy-integration" title="Permalink to this headline">¶</a></h2>
<p>The last equation in our system is the nuclear energy release,
<span class="math notranslate nohighlight">\(\edot\)</span>. Because of the operator-split approach to this ODE system,
this is not the true specific internal energy, <span class="math notranslate nohighlight">\(e\)</span> (since it only
responds only to the nuclear energy release and no pdV work).</p>
<p>At initialization, <span class="math notranslate nohighlight">\(e\)</span> is set to the value from the EOS consistent
with the initial temperature, density, and composition:</p>
<div class="math notranslate nohighlight">
\[e_0 = e(\rho_0, T_0, {X_k}_0)\]</div>
<p>In the integration routines, this is termed the “energy offset”.</p>
<p>As the system is integrated, <span class="math notranslate nohighlight">\(e\)</span> is updated to account for the
nuclear energy release,</p>
<div class="math notranslate nohighlight">
\[e(t) = e_0 + \int_{t_0}^t f(\dot{Y}_k) dt\]</div>
<p>Note that thermodynamic consistency will no longer be maintained
(because density doesn’t evolve and the <span class="math notranslate nohighlight">\(T\)</span> evolution is approximate)
but <span class="math notranslate nohighlight">\(e\)</span> will represent an approximation to the current specific
internal energy, including the nuclear energy generation release.</p>
<p>Upon exit, we subtract off this initial offset, so <code class="docutils literal notranslate"><span class="pre">%</span> <span class="pre">e</span></code> in
the returned <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> type from the <code class="docutils literal notranslate"><span class="pre">actual_integrator</span></code>
call represents the energy <em>release</em> during the burn.</p>
</div>
<div class="section" id="renormalization">
<h2>Renormalization<a class="headerlink" href="#renormalization" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">renormalize_abundances</span></code> parameter controls whether we
renormalize the abundances so that the mass fractions sum to one
during a burn. This has the positive benefit that in some cases it can
prevent the integrator from going off to infinity or otherwise go
crazy; a possible negative benefit is that it may slow down
convergence because it interferes with the integration
scheme. Regardless of whether you enable this, we will always ensure
that the mass fractions stay positive and larger than some floor
<code class="docutils literal notranslate"><span class="pre">small_x</span></code>.</p>
</div>
<div class="section" id="stiff-ode-solvers">
<span id="ch-networks-integrators"></span><h2>Stiff ODE Solvers<a class="headerlink" href="#stiff-ode-solvers" title="Permalink to this headline">¶</a></h2>
<p>We use high-order implicit ODE solvers for integrating the reaction
system.  There are several options for integrators. Each should be capable of
evolving any of the networks, but varying in their approach. Internally,
the integrators uses different data structures to store the integration
progress (from the old-style rpar array in VODE to derived
types), and each integrator needs to provide a routine to convert
from the integrator’s internal representation to the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code>
type required by the <code class="docutils literal notranslate"><span class="pre">actual_rhs</span></code> and <code class="docutils literal notranslate"><span class="pre">actual_jac</span></code> routine.</p>
<p>The name of the integrator can be selected at compile time using
the <code class="docutils literal notranslate"><span class="pre">INTEGRATOR_DIR</span></code> variable in the makefile. Presently,
the allowed options are BS and VODE.</p>
<p>We recommend that you use the VODE solver (<a class="bibtex reference internal" href="zreferences.html#vode" id="id5">[BBH89]</a>), as it is the most
robust and has both Fortran and C++ implementations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the implementation details shown below, we write the flow in
terms of the VODE solver routine names.</p>
</div>
<div class="section" id="tolerances">
<h3>Tolerances<a class="headerlink" href="#tolerances" title="Permalink to this headline">¶</a></h3>
<p>Tolerances dictate how accurate the ODE solver must be while solving
equations during a simulation.  Typically, the smaller the tolerance
is, the more accurate the results will be.  However, if the tolerance
is too small, the code may run for too long or the ODE solver will
never converge.  In these simulations, <code class="docutils literal notranslate"><span class="pre">rtol</span></code> values will set the
relative tolerances and <code class="docutils literal notranslate"><span class="pre">atol</span></code> values will set the absolute tolerances
for the ODE solver.  Often, one can find and set these values in an
input file for a simulation.</p>
<p><a class="reference internal" href="#fig-tolerances"><span class="std std-numref">Fig. 2</span></a> shows the results of a simple simulation using the
burn_cell unit test to determine
what tolerances are ideal for simulations.
For this investigation, it was assumed that a run with a tolerance of <span class="math notranslate nohighlight">\(10^{-12}\)</span>
corresponded to an exact result,
so it is used as the basis for the rest of the tests.
From the figure, one can infer that the <span class="math notranslate nohighlight">\(10^{-3}\)</span> and <span class="math notranslate nohighlight">\(10^{-6}\)</span> tolerances
do not yeild the most accurate results
because their relative error values are fairly large.
However, the test with a tolerance of <span class="math notranslate nohighlight">\(10^{-9}\)</span> is accurate
and not so low that it takes incredible amounts of computer time,
so <span class="math notranslate nohighlight">\(10^{-9}\)</span> should be used as the default tolerance in future simulations.</p>
<div class="figure align-default" id="id12">
<span id="fig-tolerances"></span><a class="reference internal image-reference" href="_images/tolerances.png"><img alt="Relative error plot" src="_images/tolerances.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Relative error of runs with varying tolerances as compared
to a run with an ODE tolerance of <span class="math notranslate nohighlight">\(10^{-12}\)</span>.</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</div>
<p>The integration tolerances for the burn are controlled by
<code class="docutils literal notranslate"><span class="pre">rtol_spec</span></code>, <code class="docutils literal notranslate"><span class="pre">rtol_enuc</span></code>, and <code class="docutils literal notranslate"><span class="pre">rtol_temp</span></code>,
which are the relative error tolerances for
<a class="reference internal" href="#equation-eq-spec-integrate">(1)</a>, <a class="reference internal" href="#equation-eq-enuc-integrate">(2)</a>, and
<a class="reference internal" href="#equation-eq-temp-integrate">(3)</a>, respectively. There are corresponding
<code class="docutils literal notranslate"><span class="pre">atol</span></code> parameters for the absolute error tolerances. Note that
not all integrators handle error tolerances the same way—see the
sections below for integrator-specific information.</p>
<p>The absolute error tolerances are set by default
to <span class="math notranslate nohighlight">\(10^{-12}\)</span> for the species, and a relative tolerance of <span class="math notranslate nohighlight">\(10^{-6}\)</span>
is used for the temperature and energy.</p>
</div>
<div class="section" id="fortran-interfaces">
<h3>Fortran interfaces<a class="headerlink" href="#fortran-interfaces" title="Permalink to this headline">¶</a></h3>
<div class="section" id="integrator">
<h4><code class="docutils literal notranslate"><span class="pre">integrator</span></code><a class="headerlink" href="#integrator" title="Permalink to this headline">¶</a></h4>
<p>The entry point to the integrator is <code class="docutils literal notranslate"><span class="pre">integrator()</span></code> in
<code class="docutils literal notranslate"><span class="pre">integration/integrator.F90</span></code>.  This does some setup and then calls
the specific integration routine, e.g., <code class="docutils literal notranslate"><span class="pre">vode_integrator()</span></code> in
<code class="docutils literal notranslate"><span class="pre">integration/VODE/vode_integrator.F90</span></code>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">vode_integrator</span><span class="p">(</span><span class="n">state_in</span><span class="p">,</span> <span class="n">state_out</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

  <span class="k">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span>   <span class="p">)</span> <span class="kd">::</span> <span class="n">state_in</span>
  <span class="k">type</span> <span class="p">(</span><span class="n">burn_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state_out</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">rt</span><span class="p">),</span>    <span class="k">intent</span><span class="p">(</span><span class="n">in</span>   <span class="p">)</span> <span class="kd">::</span> <span class="n">dt</span><span class="p">,</span> <span class="nb">time</span>
<span class="nb">  </span><span class="k">type</span> <span class="p">(</span><span class="n">integration_status_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">status</span>
</pre></div>
</div>
<p>A basic flow chart of this interface is as follows (note: there are
many conversions between <code class="docutils literal notranslate"><span class="pre">eos_t</span></code>, <code class="docutils literal notranslate"><span class="pre">burn_t</span></code>, and any
integrator-specific type implied in these operations):</p>
<ol class="arabic">
<li><p>Call the EOS on the input state, using <span class="math notranslate nohighlight">\(\rho, T\)</span> as the input
variables.</p>
<p>This involves:</p>
<ol class="arabic simple">
<li><p>calling <code class="docutils literal notranslate"><span class="pre">burn_to_eos</span></code> to produce an <code class="docutils literal notranslate"><span class="pre">eos_t</span></code>
with the thermodynamic information.</p></li>
<li><p>calling the EOS</p></li>
<li><p>calling <code class="docutils literal notranslate"><span class="pre">eos_to_vode</span></code> to produce a <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> type
containing all of the relevant
data into the internal representation used by the integrator.
Data that is not part of the integration state is stored in an <code class="docutils literal notranslate"><span class="pre">rpar</span></code>
array that is indexed using the integer keys in <code class="docutils literal notranslate"><span class="pre">vode_rpar_indices</span></code>.</p></li>
</ol>
<p>We use the EOS result to define the energy offset for <span class="math notranslate nohighlight">\(e\)</span>
integration.</p>
</li>
<li><p>Compute the initial <span class="math notranslate nohighlight">\(d(c_x)/dT\)</span> derivatives, if necessary, by
finite differencing on the temperature.</p></li>
<li><p>Call the main integration routine, <code class="docutils literal notranslate"><span class="pre">dvode()</span></code>, passing in the
<code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> state to advance the inputs state through the desired
time interval, producing the new, output state.</p></li>
<li><p>If necessary (integration failure, burn_mode demands)
do any retries of the integration</p></li>
<li><p>Subtract off the energy offset—we now store just the
energy release as <code class="docutils literal notranslate"><span class="pre">state_out</span> <span class="pre">%</span> <span class="pre">e</span></code></p></li>
<li><p>Convert back to a <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> type (by <code class="docutils literal notranslate"><span class="pre">calling</span> <span class="pre">vode_to_burn</span></code>).</p></li>
<li><p>normalize the abundances so they sum to 1</p></li>
</ol>
</div>
<div class="section" id="righthand-side-wrapper">
<h4>Righthand side wrapper<a class="headerlink" href="#righthand-side-wrapper" title="Permalink to this headline">¶</a></h4>
<p>Each integrator does their own thing to construct the solution,
but they will all need to assess the RHS in <code class="docutils literal notranslate"><span class="pre">actual_rhs</span></code>,
which means converting from their internal representation
to the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> type. This is handled in a file
called <code class="docutils literal notranslate"><span class="pre">vode_rhs.F90</span></code>.
The basic outline of this routine is:</p>
<ol class="arabic">
<li><p>call <code class="docutils literal notranslate"><span class="pre">clean_state</span></code></p>
<p>This function operates on the ODE integrator vector directly
(accessing it from the integrator’s internal data structure). It
makes sure that the mass fractions lie between <code class="docutils literal notranslate"><span class="pre">SMALL_X_SAFE</span></code> and 1  and
that the temperature lies between <span class="math notranslate nohighlight">\([{\tt small\_temp}, {\tt MAX_TEMP}]\)</span>. The
latter upper limit is arbitrary, but is safe for the types of problems
we support with these networks.</p>
<p>It also renormalizes the species, if <code class="docutils literal notranslate"><span class="pre">renormalize_abundances</span> <span class="pre">=</span> <span class="pre">T</span></code></p>
</li>
<li><p>update the thermodynamic quantities by calling
<code class="docutils literal notranslate"><span class="pre">update_thermodynamics()</span></code></p>
<p>among other things, this will handle the <code class="docutils literal notranslate"><span class="pre">call_eos_in_rhs</span></code> option
or if the <code class="docutils literal notranslate"><span class="pre">dT_crit</span></code> requires the EOS call.</p>
</li>
<li><p>call <code class="docutils literal notranslate"><span class="pre">vode_to_burn</span></code> to convert to a <code class="docutils literal notranslate"><span class="pre">burn_t</span></code></p></li>
<li><p>call the actual RHS</p></li>
<li><p>convert derivatives to mass-fraction-based (since we integrate <span class="math notranslate nohighlight">\(X\)</span>),
and zero out the temperature or
energy derivatives (if <code class="docutils literal notranslate"><span class="pre">integrate_temperature</span> <span class="pre">=</span> <span class="pre">F</span></code> or
<code class="docutils literal notranslate"><span class="pre">integrate_energy</span> <span class="pre">=</span> <span class="pre">F</span></code>, respectively).</p></li>
<li><p>apply any boosting to the rates if <code class="docutils literal notranslate"><span class="pre">react_boost</span></code> &gt; 0.</p></li>
<li><p>convert back to the integrator’s internal representation by calling <code class="docutils literal notranslate"><span class="pre">burn_to_vode</span></code></p></li>
</ol>
</div>
<div class="section" id="jacobian-wrapper">
<h4>Jacobian wrapper<a class="headerlink" href="#jacobian-wrapper" title="Permalink to this headline">¶</a></h4>
<p>Similar to the RHS, the Jacobian wrapper is handled in the same
<code class="docutils literal notranslate"><span class="pre">vode_rhs.f90</span></code>.
The basic outline of this routine is:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the thermodynamics are already correct when
calling the Jacobian wrapper, likely because we just called the RHS
wrapper above which did the <code class="docutils literal notranslate"><span class="pre">clean_state</span></code> and
<code class="docutils literal notranslate"><span class="pre">update_thermodynamics</span></code> calls.</p>
</div>
<ol class="arabic simple">
<li><p>call <code class="docutils literal notranslate"><span class="pre">vode_to_burn</span></code> to convert to a <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> type.</p></li>
<li><p>call the actual Jacobian routine</p></li>
<li><p>convert derivatives to mass-fraction-based (since we integrate <span class="math notranslate nohighlight">\(X\)</span>),
and zero out the temperature or
energy derivatives (if <code class="docutils literal notranslate"><span class="pre">integrate_temperature</span> <span class="pre">=</span> <span class="pre">F</span></code> or
<code class="docutils literal notranslate"><span class="pre">integrate_energy</span> <span class="pre">=</span> <span class="pre">F</span></code>, respectively).</p></li>
<li><p>apply any boosting to the rates if <code class="docutils literal notranslate"><span class="pre">react_boost</span></code> &gt; 0.</p></li>
<li><p>convert back to the integrator’s internal representation by calling <code class="docutils literal notranslate"><span class="pre">burn_to_vode</span></code></p></li>
</ol>
</div>
</div>
<div class="section" id="c-interfaces">
<h3>C++ interfaces<a class="headerlink" href="#c-interfaces" title="Permalink to this headline">¶</a></h3>
<div class="section" id="burner">
<h4><code class="docutils literal notranslate"><span class="pre">burner</span></code><a class="headerlink" href="#burner" title="Permalink to this headline">¶</a></h4>
<p>The main entry point for C++ is <code class="docutils literal notranslate"><span class="pre">burner()</span></code> in
<code class="docutils literal notranslate"><span class="pre">interfaces/burner.H</span></code>.  This simply calls the <code class="docutils literal notranslate"><span class="pre">integrator()</span></code>
routine, which at the moment is only provided by VODE.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMREX_GPU_HOST_DEVICE</span> <span class="n">AMREX_FORCE_INLINE</span>
<span class="kt">void</span> <span class="n">burner</span> <span class="p">(</span><span class="n">burn_t</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>The basic flow of the <code class="docutils literal notranslate"><span class="pre">integrator()</span></code> routine mirrors the Fortran one.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The C++ VODE integrator does not use a separate <code class="docutils literal notranslate"><span class="pre">rpar</span></code> array as
part of the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> type.  Instead, any auxillary information
is kept in the original <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> that was passed into the
integration routines.  For this reason, we often need to pass both
the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> and <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> objects into the network routines.</p>
</div>
<ol class="arabic">
<li><p>Call the EOS on the input <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> state.  This involves:</p>
<ol class="arabic simple">
<li><p>calling <code class="docutils literal notranslate"><span class="pre">burn_to_eos</span></code> to convert the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> to an <code class="docutils literal notranslate"><span class="pre">eos_t</span></code></p></li>
<li><p>calling the EOS with <span class="math notranslate nohighlight">\(\rho\)</span> and <span class="math notranslate nohighlight">\(T\)</span> as input</p></li>
<li><p>calling <code class="docutils literal notranslate"><span class="pre">eos_to_burn</span></code> to convert the <code class="docutils literal notranslate"><span class="pre">eos_t</span></code> back to a <code class="docutils literal notranslate"><span class="pre">burn_t</span></code></p></li>
</ol>
</li>
<li><p>Fill the integrator type by calling <code class="docutils literal notranslate"><span class="pre">burn_to_vode</span></code> to create a
<code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> from the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>unlike the Fortran interface, there is no <code class="docutils literal notranslate"><span class="pre">vode_to_eos</span></code> routine in C++</p>
</div>
</li>
<li><p>Compute the initial <span class="math notranslate nohighlight">\(d(c_x)/dt\)</span> derivatives</p></li>
<li><p>call the ODE integrator, <code class="docutils literal notranslate"><span class="pre">dvode()</span></code>, passing in the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> _and_ the
<code class="docutils literal notranslate"><span class="pre">burn_t</span></code> — as noted above, the auxillary information that is
not part of the integration state will be obtained from the
<code class="docutils literal notranslate"><span class="pre">burn_t</span></code>.</p></li>
<li><p>subtract off the energy offset—we now store just the energy released
in the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> integration state.</p></li>
<li><p>convert back to a <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> by calling <code class="docutils literal notranslate"><span class="pre">vode_to_burn</span></code></p></li>
<li><p>normalize the abundances so they sum to 1.</p></li>
</ol>
</div>
<div class="section" id="sec-bs">
<span id="id6"></span><h4>Righthand side wrapper<a class="headerlink" href="#sec-bs" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>call <code class="docutils literal notranslate"><span class="pre">clean_state</span></code> on the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code></p></li>
<li><p>update the thermodynamics by calling <code class="docutils literal notranslate"><span class="pre">update_thermodynamics</span></code>.  This takes both
the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> and the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code>.</p></li>
<li><p>call <code class="docutils literal notranslate"><span class="pre">vode_to_burn</span></code> to update the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code></p></li>
<li><p>call <code class="docutils literal notranslate"><span class="pre">actual_rhs</span></code></p></li>
<li><p>convert the derivatives to mass-fraction-based (since we integrate <span class="math notranslate nohighlight">\(X\)</span>)
and zero out the temperature and energy derivatives if we are not integrating
those quantities.</p></li>
<li><p>apply any boosting if <code class="docutils literal notranslate"><span class="pre">react_boost</span></code> &gt; 0</p></li>
<li><p>convert back to the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code> by calling <code class="docutils literal notranslate"><span class="pre">burn_to_vode</span></code></p></li>
</ol>
</div>
<div class="section" id="id7">
<h4>Jacobian wrapper<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the thermodynamics are already correct when
calling the Jacobian wrapper, likely because we just called the RHS
wrapper above which did the <code class="docutils literal notranslate"><span class="pre">clean_state</span></code> and
<code class="docutils literal notranslate"><span class="pre">update_thermodynamics</span></code> calls.</p>
</div>
<ol class="arabic simple">
<li><p>call <code class="docutils literal notranslate"><span class="pre">vode_to_burn</span></code> to update the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code></p></li>
<li><p>call <code class="docutils literal notranslate"><span class="pre">actual_jac()</span></code> to have the network fill the Jacobian array</p></li>
<li><p>convert the derivative to be mass-fraction-based</p></li>
<li><p>apply any boosting to the rates if <code class="docutils literal notranslate"><span class="pre">react_boost</span></code> &gt; 0</p></li>
<li><p>call <code class="docutils literal notranslate"><span class="pre">burn_to_vode</span></code> to update the <code class="docutils literal notranslate"><span class="pre">dvode_t</span></code></p></li>
</ol>
</div>
</div>
<div class="section" id="bs">
<h3>BS<a class="headerlink" href="#bs" title="Permalink to this headline">¶</a></h3>
<p>This integrator is based on the stiff-ODE methods from <a class="bibtex reference internal" href="zreferences.html#nr" id="id8">[PressTeukolskyVetterlingFlannery92]</a>, but
written with reaction network integration in mind (so it knows about
species), and in a modular / threadsafe fashion to work with our data
structures. This integrator appears quite robust.</p>
<div class="section" id="bs-t-data-structure">
<h4>bs_t data structure.<a class="headerlink" href="#bs-t-data-structure" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">bs_t</span></code> type is the main data structure for the BS integrator.
This holds the integration variables (as <code class="docutils literal notranslate"><span class="pre">y(1:neqs)</span></code>) and data
associated with the timestepping. It also holds a <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> type
as <code class="docutils literal notranslate"><span class="pre">bs_t</span> <span class="pre">%</span> <span class="pre">burn_s</span></code>. This component is used to interface with
the networks. The conversion routines <code class="docutils literal notranslate"><span class="pre">bs_to_burn</span></code> and
<code class="docutils literal notranslate"><span class="pre">burn_to_bs</span></code> simply sync up <code class="docutils literal notranslate"><span class="pre">bs_t</span> <span class="pre">%</span> <span class="pre">y(:)</span></code> and <code class="docutils literal notranslate"><span class="pre">bs_t</span> <span class="pre">%</span> <span class="pre">burn_s</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">upar(:)</span></code> component contains the meta-data that is not held in
the <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> but nevertheless is associate with the current
state. This is an array that can be indexed via the integers define
in the <code class="docutils literal notranslate"><span class="pre">rpar_indices</span></code> module. Note that because the <code class="docutils literal notranslate"><span class="pre">bs_t</span></code>
contains its own <code class="docutils literal notranslate"><span class="pre">burn_t</span></code> type, the BS integrator does not need
as much meta-data as some other integrators. The fields of upar
are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bs_t</span> <span class="pre">%</span> <span class="pre">upar(irp_t_sound)</span></code></p>
<p>This is the sound-crossing time for a zone.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bs_t</span> <span class="pre">%</span> <span class="pre">upar(irp_t0)</span></code></p>
<p>This is the simulation time at the start of integration. This can be
used as an offset to convert between simulation time and integration
time (we always start the integration at <span class="math notranslate nohighlight">\(t = 0\)</span>).</p>
</li>
</ul>
</div>
<div class="section" id="error-criteria">
<h4>Error criteria.<a class="headerlink" href="#error-criteria" title="Permalink to this headline">¶</a></h4>
<p>There is a single relative tolerance used for all ODEs, instead of a
separate one for species, temperature, and energy, it is simply the
maximum of {<code class="docutils literal notranslate"><span class="pre">rtol_spec</span></code>, <code class="docutils literal notranslate"><span class="pre">rtol_temp</span></code>, <code class="docutils literal notranslate"><span class="pre">rtol_enuc</span></code>}. The absolute
tolerance parameters are ignored.</p>
<p>A relative tolerance needs a metric against which to compare. BS
has two options, chosen by the runtime parameter scaling_method.
Considering a vector <span class="math notranslate nohighlight">\({\bf y} = (Y_k, e, T)^\intercal\)</span>, the scales
to compare against, <span class="math notranslate nohighlight">\({\bf y}_\mathrm{scal}\)</span>, are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">scaling_method</span></code> = 1 :</p>
<div class="math notranslate nohighlight">
\[{\bf y}_\mathrm{scal} = |{\bf y}| + \Delta t  |\dot{\bf y}| + \epsilon\]</div>
<p>This is an extrapolation of <span class="math notranslate nohighlight">\({\bf y}\)</span> in time. The quantity
<span class="math notranslate nohighlight">\(\epsilon\)</span> is a small number (hardcoded to <span class="math notranslate nohighlight">\(10^{-30}\)</span>)
to prevent any scale from being zero.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">scaling_method</span></code> = 2 :</p>
<div class="math notranslate nohighlight">
\[({y}_\mathrm{scal})_j = \max \left (|y_j|, \mathtt{ode\_scale\_floor} \right )\]</div>
<p>for <span class="math notranslate nohighlight">\(j = 1, \ldots, {\tt neq}\)</span>.  Here, <code class="docutils literal notranslate"><span class="pre">ode_scale_floor</span></code> is
a runtime parameter that sets a lower-limit to the scaling for each
variable in the vector <span class="math notranslate nohighlight">\({\bf y}_\mathrm{scal}\)</span>. The default
value is currently <span class="math notranslate nohighlight">\(10^{-6}\)</span> (although any network can
override this using priorities). The effect of this scaling is that
species with an abundance <span class="math notranslate nohighlight">\(\ll\)</span> <code class="docutils literal notranslate"><span class="pre">ode_scal_floor</span></code> will not be
used as strongly in assessing the accuracy of a step.</p>
</li>
</ul>
<p>These correspond to the options presented in <a class="bibtex reference internal" href="zreferences.html#nr" id="id9">[PressTeukolskyVetterlingFlannery92]</a>.</p>
<p>A final option, use_timestep_estimator enables the
timestep estimator from VODE to determine a good starting
timestep for integration.</p>
</div>
</div>
<div class="section" id="retries">
<span id="sec-vode"></span><h3>Retries<a class="headerlink" href="#retries" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="overriding-parameter-defaults-on-a-network-by-network-basis">
<h2>Overriding Parameter Defaults on a Network-by-Network Basis<a class="headerlink" href="#overriding-parameter-defaults-on-a-network-by-network-basis" title="Permalink to this headline">¶</a></h2>
<p>Any network can override or add to any of the existing runtime
parameters by creating a <code class="docutils literal notranslate"><span class="pre">_parameters</span></code> file in the network directory
(e.g., <code class="docutils literal notranslate"><span class="pre">networks/triple_alpha_plus_cago/_parameters</span></code>). As noted in
Chapter [chapter:parameters], the fourth column in the <code class="docutils literal notranslate"><span class="pre">_parameter</span></code>
file definition is the <em>priority</em>. When a duplicate parameter is
encountered by the scripts writing the <code class="docutils literal notranslate"><span class="pre">extern_probin_module</span></code>, the value
of the parameter with the highest priority is used. So picking a large
integer value for the priority in a network’s <code class="docutils literal notranslate"><span class="pre">_parameter</span></code> file will
ensure that it takes precedence.</p>
<p><img alt="image" src="_images/doxygen_network.png" /></p>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Note that in previous versions of our networks in
CASTRO and MAESTRO, there was another term in the temperature
equation relating to the chemical potential of the gas as it came
from the EOS. We have since decided that this term should
analytically cancel to zero in all cases for our nuclear networks,
and so we no longer think it is correct to include a numerical
approximation of it in the integration scheme. So the current
results given by our networks will in general be a little different
than in the past.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Note: each integrator provides its
own implementation of this, since it operates on the internal
data-structure of the integrator, but the basic procedure is the
same.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="transport.html" class="btn btn-neutral float-right" title="Transport Coefficients" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="networks.html" class="btn btn-neutral float-left" title="Reaction Networks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018, StarKiller Development Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    


</body>
</html>