

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Automatic Differentiation &mdash; Microphysics  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css?v=2e394b92" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="_static/copybutton.js?v=eaa7b67c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "processEscapes": true, "displayMath": [["\\[", "\\]"]], "macros": {"rhozero": "{\\rho_0}", "pizero": "{\\pi_0}", "pizeroone": "{\\pi_0^{(1)}}", "pizerotwo": "{\\pi_0^{(2)}}", "gammabar": "{\\overline{\\Gamma}_1}", "ptl": "{{\\partial}}", "eb": "{{\\bf e}}", "fb": "{{\\bf f}}", "ib": "{{\\bf i}}", "Ub": "{{\\bf U}}", "Vb": "{{\\bf V}}", "xb": "{{\\bf x}}", "ut": "{\\tilde{u}}", "vt": "{\\tilde{v}}", "wt": "{\\tilde{w}}", "Ubt": "{\\widetilde{\\Ub}}", "edge": "{\\rm EDGE}", "mac": "{\\rm MAC}", "trans": "{\\rm TRANS}", "nablab": "{\\mathbf{\\nabla}}", "cdotb": "{\\mathbf{\\cdot}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\frac{1}{2}}", "nph": "{{n + \\myhalf}}", "nmh": "{{n - \\myhalf}}", "Hext": "{{H_{\\rm ext}}}", "Hnuc": "{{H_{\\rm nuc}}}", "kth": "{k_{\\rm th}}", "pred": "{{\\rm pred}}", "Sbar": "{\\overline{S}}", "inp": "{\\mathrm{in}}", "initp": "{\\mathrm{init}}", "outp": "{\\mathrm{out}}", "uadv": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV}}}", "uadvone": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV},\\star}}", "uadvonedag": "{\\Ubt^{\\mathrm{ADV},\\dagger,\\star}}", "uadvtwo": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV}}}", "uadvtwodag": "{\\Ubt^{\\mathrm{ADV},\\dagger}}", "uadvsdcstar": "{\\mathbf{U}^{\\mathrm{ADV},\\star}}", "uadvsdcpred": "{\\mathbf{U}^{\\mathrm{ADV},\\mathrm{pred}}}", "uadvsdc": "{\\mathbf{U}^{\\mathrm{ADV}}}", "dt": "{\\Delta t}", "dr": "{\\Delta r}", "etarho": "{\\eta_{\\rho}}", "etarhoec": "{\\etarho^{\\rm ec}}", "etarhocc": "{\\etarho^{\\rm cc}}", "etarhoflux": "{\\etarho^{\\rm flux}}", "divetarho": "{\\nabla\\cdot(\\etarho\\eb_r)}", "ow": "{\\overline{w}_0}", "dw": "{\\delta w_0}", "thalf": "{\\sfrac{3}{2}}", "rhop": "{{\\rho^{\\prime}}}", "omegadot": "{\\dot{\\omega}}", "er": "{\\mathbf{e}_r}", "ex": "{\\mathbf{e}_x}", "ey": "{\\mathbf{e}_y}", "ez": "{\\mathbf{e}_z}", "Omegab": "{{\\bf \\Omega}}", "rb": "{{\\bf r}}", "isotm": ["{{}^{#2}\\mathrm{#1}}", 2], "edot": "{{{\\dot{e}_\\mathrm{nuc}}}}", "enuc": "{{{{e}_\\mathrm{nuc}}}}", "edotnu": "{{{\\dot{e}_\\nu}}}", "rt": "{\\tilde{r}_0}", "rhob": "{\\ensuremath{\\rho_\\mathrm{base}}}", "Tb": "{\\ensuremath{T_\\mathrm{base}}}", "gcc": "{\\mathrm{g~cm^{-3} }}", "pb": "{p_\\mathrm{base}}", "qburn": "{q_\\mathrm{burn}}", "Uc": "{{\\boldsymbol{\\mathcal{U}}}}", "Fb": "{\\mathbf{F}}", "Sc": "{\\mathbf{S}}", "Shydro": "{{{\\bf S}^{\\mathrm{hydro}}}}", "Rb": "{{\\bf R}}", "Rbs": ["{{\\bf R} \\left ( #1 \\right )}", 1], "Rq": "{{\\bf R}}", "Adv": ["{{\\left [\\boldsymbol{\\mathcal{A}} \\left(#1\\right)\\right]}}", 1], "Advs": ["{{\\boldsymbol{\\mathcal{A}} \\left(#1\\right)}}", 1], "Sdot": "{\\dot{S}}"}}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Overview of Unit Tests" href="unit_tests.html" />
    <link rel="prev" title="Helper Functions and Libraries" href="util.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


          
          
          <a href="index.html" class="icon icon-home">
            Microphysics
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
    <div class="branch">
        Branch: <a href="./autodiff.html">main</a> | <a href="./dev/autodiff.html">development</a>
    </div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Microphysics overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_system.html">Build System</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="fundamental_constants.html">Fundamental Constants</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">EOS and transport</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="eos.html">Equations of State</a></li>
<li class="toctree-l1"><a class="reference internal" href="eos_implementations.html">Available Equations of State</a></li>
<li class="toctree-l1"><a class="reference internal" href="transport.html">Transport Coefficients</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reaction networks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="networks-overview.html">Overview of Reaction Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="networks.html">Available Reaction Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="templated_networks.html">Templated Network Righthand Sides</a></li>
<li class="toctree-l1"><a class="reference internal" href="screening.html">Screening of Reaction Rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="neutrinos.html">Neutrino Losses</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ODE integrators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="integrators.html">Reaction ODE System</a></li>
<li class="toctree-l1"><a class="reference internal" href="ode_integrators.html">ODE Integrators</a></li>
<li class="toctree-l1"><a class="reference internal" href="nse.html">NSE</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Util / external libraries</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="util.html">Helper Functions and Libraries</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Automatic Differentiation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#derivatives-of-single-variable-functions">Derivatives of single-variable functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#derivatives-of-multi-variable-functions">Derivatives of multi-variable functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#partial-arrays">Partial arrays</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unit tests</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="unit_tests.html">Overview of Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="unit_test_runtime_parameters.html">Unit Test Common Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="comprehensive_tests.html">Comprehensive Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="one_zone_tests.html">One Zone Tests</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="citing.html">Citing Microphysics</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Index</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Microphysics</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Automatic Differentiation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/autodiff.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="automatic-differentiation">
<h1>Automatic Differentiation<a class="headerlink" href="#automatic-differentiation" title="Link to this heading"></a></h1>
<p>Support for automatic differentiation is provided by the <code class="docutils literal notranslate"><span class="pre">autodiff</span></code>
library <span id="id1">[<a class="reference internal" href="zreferences.html#id45" title="Allan M. M. Leal. Autodiff, a modern, fast and expressive C++ library for automatic differentiation. 2018. URL: https://autodiff.github.io.">50</a>]</span>, included under
<code class="docutils literal notranslate"><span class="pre">Microphysics/util/autodiff</span></code>.  We use the forward mode <code class="docutils literal notranslate"><span class="pre">dual</span></code>
implementation, which produces the derivative of each computation along
with its output value.  This results in largely the same arithmetic
operations as manually calculating the analytical derivative of each
intermediate step, but with much less code and fewer typos.  All the
machinery needed for use in Microphysics is located in
<code class="docutils literal notranslate"><span class="pre">Microphysics/util/microphysics_autodiff.H</span></code>.</p>
<p>Most functions can be updated to support <code class="docutils literal notranslate"><span class="pre">autodiff</span></code> by adding a
template parameter for the numeric type (the current code calls it
<code class="docutils literal notranslate"><span class="pre">number_t</span></code>).  This should be used for any values that depend on the
variables we’re differentiating with respect to.  Calls to functions
from <code class="docutils literal notranslate"><span class="pre">&lt;cmath&gt;</span></code> as well as <code class="docutils literal notranslate"><span class="pre">amrex::min</span></code>, <code class="docutils literal notranslate"><span class="pre">amrex::max</span></code>, and
<code class="docutils literal notranslate"><span class="pre">amrex::Math::powi</span></code> can be
replaced with ones in the <code class="docutils literal notranslate"><span class="pre">admath</span></code> namespace.  This namespace also
exports the original functions, so they work fine on normal numeric
types too.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The <code class="docutils literal notranslate"><span class="pre">autodiff</span></code> library uses expression templates to optimize some
expressions, which can cause compilation errors when trying to pass
expressions using <code class="docutils literal notranslate"><span class="pre">autodiff::dual</span></code> to other templated functions.
To avoid this, either use the corresponding function from <code class="docutils literal notranslate"><span class="pre">admath</span></code>,
or wrap the expression with <code class="docutils literal notranslate"><span class="pre">autodiff::eval()</span></code> before passing it to
the templated function.</p>
</div>
<p>To manually check whether a type is a dual number or not, use
<code class="docutils literal notranslate"><span class="pre">autodiff::detail::isDual&lt;number_t&gt;</span></code>.</p>
<section id="derivatives-of-single-variable-functions">
<h2>Derivatives of single-variable functions<a class="headerlink" href="#derivatives-of-single-variable-functions" title="Link to this heading"></a></h2>
<p>To take the derivative of some computation <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> must be an
<code class="docutils literal notranslate"><span class="pre">autodiff::dual</span></code>, and has to be seeded with <code class="docutils literal notranslate"><span class="pre">autodiff::seed()</span></code>
before the function is called:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">autodiff</span><span class="o">::</span><span class="n">dual</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="n">_rt</span><span class="p">;</span>
<span class="n">autodiff</span><span class="o">::</span><span class="n">seed</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">autodiff</span><span class="o">::</span><span class="n">dual</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>We can then use <code class="docutils literal notranslate"><span class="pre">autodiff::val(result)</span></code> or
<code class="docutils literal notranslate"><span class="pre">static_cast&lt;amrex::Real&gt;(result)</span></code> to extract the function value, and
<code class="docutils literal notranslate"><span class="pre">autodiff::derivative(result)</span></code> to get the derivative with respect to
x.  The <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> version has the advantage of working on normal
numbers as well.</p>
<p><code class="docutils literal notranslate"><span class="pre">autodiff::seed(x)</span></code> sets the derivative term of <code class="docutils literal notranslate"><span class="pre">x</span></code> to 1 (it is equivalent
to <code class="docutils literal notranslate"><span class="pre">x.grad</span> <span class="pre">=</span> <span class="pre">1.0</span></code>), which effectively tells the code that
<span class="math notranslate nohighlight">\({\partial x}/{\partial x} = 1\)</span>. This propagates through any
operations that <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> does, and we end up with <span class="math notranslate nohighlight">\({\partial
f(x)}/{\partial x}\)</span> in the derivative term of <code class="docutils literal notranslate"><span class="pre">result</span></code>.</p>
</section>
<section id="derivatives-of-multi-variable-functions">
<h2>Derivatives of multi-variable functions<a class="headerlink" href="#derivatives-of-multi-variable-functions" title="Link to this heading"></a></h2>
<p>It is possible to calculate derivatives with respect to several input
variables in a single pass, by using a (mathematical) vector of
derivative terms instead of a single number.  This is known as “vector
mode” automatic differentiation, and can save time when the function
evaluation code is much more expensive than the derivative calculations.</p>
<p>The interface is very
similar to the single-variable case, with slight modifications: for
<code class="docutils literal notranslate"><span class="pre">N</span></code> input variables, we use <code class="docutils literal notranslate"><span class="pre">autodiff::dual_array&lt;1,</span> <span class="pre">N&gt;</span></code> in place of
<code class="docutils literal notranslate"><span class="pre">autodiff::dual</span></code>, and pass the variables in order to
<code class="docutils literal notranslate"><span class="pre">autodiff::seed_array()</span></code>.  After calling the function, we can extract
the derivatives using structured binding declarations, as shown in the
following example program:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;AMReX_REAL.H&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;microphysics_autodiff.H&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">amrex</span><span class="o">::</span><span class="nn">literals</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">number_t</span><span class="o">&gt;</span>
<span class="n">number_t</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">number_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">number_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">admath::sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">admath</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">number_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">autodiff</span><span class="o">::</span><span class="n">dual_array</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">number_t</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="n">number_t</span><span class="w"> </span><span class="n">x_dual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.41</span><span class="p">,</span><span class="w"> </span><span class="n">y_dual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.38</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// seed the inputs</span>
<span class="w">    </span><span class="n">autodiff</span><span class="o">::</span><span class="n">seed_array</span><span class="p">(</span><span class="n">x_dual</span><span class="p">,</span><span class="w"> </span><span class="n">y_dual</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// compute the function and both derivatives in a single pass</span>
<span class="w">    </span><span class="n">number_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x_dual</span><span class="p">,</span><span class="w"> </span><span class="n">y_dual</span><span class="p">);</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">dfdx</span><span class="p">,</span><span class="w"> </span><span class="n">dfdy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">autodiff</span><span class="o">::</span><span class="n">derivative</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;f(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">autodiff</span><span class="o">::</span><span class="n">val</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;df/dx = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dfdx</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;df/dy = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dfdy</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="partial-arrays">
<h3>Partial arrays<a class="headerlink" href="#partial-arrays" title="Link to this heading"></a></h3>
<p>If an intermediate value only depends on some of the variables in an
<code class="docutils literal notranslate"><span class="pre">autodiff::dual_array</span></code>, we can save time and memory by not calculating
or storing the derivatives with respect to the other variables.  This is
done by assigning such values to a smaller <code class="docutils literal notranslate"><span class="pre">dual_array</span></code> with indices
that match the full <code class="docutils literal notranslate"><span class="pre">dual_array</span></code>.  Any operations between these
partial arrays will skip the unused components at compile time.
Operations that combine different ranges will produce a promoted type
that holds all the components between the minimum and maximum indices
present.  For example, multiplying a <code class="docutils literal notranslate"><span class="pre">dual_array&lt;1,</span> <span class="pre">1&gt;</span></code> and a
<code class="docutils literal notranslate"><span class="pre">dual_array&lt;2,</span> <span class="pre">3&gt;</span></code> will produce a <code class="docutils literal notranslate"><span class="pre">dual_array&lt;1,</span> <span class="pre">3&gt;</span></code>.  Partial
arrays can be implicitly converted into a wider array type, but
converting to a narrower array type must explicitly use the
<code class="docutils literal notranslate"><span class="pre">autodiff::narrow_array</span></code> function (to prevent derivative components
from being accidentally discarded).  This function takes the target type
as a template parameter, and returns its argument converted to that
type.</p>
<p>Partial <code class="docutils literal notranslate"><span class="pre">dual_arrays</span></code> can be created with the
<code class="docutils literal notranslate"><span class="pre">autodiff::make_partial_arrays()</span></code> helper function, which takes the
full array range as template parameters and the values for each variable
as arguments.  It returns a tuple of seeded partial arrays, which can be
unpacked using a structured binding declaration.  The following line
defines <code class="docutils literal notranslate"><span class="pre">dual_array&lt;1,</span> <span class="pre">1&gt;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1.0_rt</span></code> and <code class="docutils literal notranslate"><span class="pre">dual_array&lt;2,</span> <span class="pre">2&gt;</span> <span class="pre">y</span> <span class="pre">=</span>
<span class="pre">2.0_rt</span></code> and seeds both of their derivative terms.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">autodiff</span><span class="o">::</span><span class="n">make_partial_arrays</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="n">_rt</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="n">_rt</span><span class="p">);</span>
</pre></div>
</div>
<p>The recommended way to use partial arrays is to declare each
intermediate value with <code class="docutils literal notranslate"><span class="pre">auto</span></code> and wrap each expression with
<code class="docutils literal notranslate"><span class="pre">autodiff::eval()</span></code>, as shown in this example code (using the variables
declared above):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">autodiff</span><span class="o">::</span><span class="n">eval</span><span class="p">;</span>

<span class="c1">// this only computes the derivative terms with respect to x</span>
<span class="c1">// (type is dual_array&lt;1, 1&gt;)</span>
<span class="k">auto</span><span class="w"> </span><span class="n">x_squared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="c1">// this only computes the derivative terms with respect to y</span>
<span class="c1">// (type is dual_array&lt;2, 2&gt;)</span>
<span class="k">auto</span><span class="w"> </span><span class="n">sin_2y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">admath</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="n">_rt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">));</span>

<span class="c1">// partial arrays are promoted as needed by overloaded operators</span>
<span class="c1">// (type is dual_array&lt;1, 2&gt;)</span>
<span class="k">auto</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">x_squared</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin_2y</span><span class="p">);</span>
</pre></div>
</div>
<p>The following is equivalent to the code above, but requires more care to
keep the types and expressions in sync:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">autodiff</span><span class="o">::</span><span class="n">dual_array</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// this only computes the derivative terms with respect to x</span>
<span class="w"> </span><span class="n">dual_array</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x_squared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w"> </span><span class="c1">// this only computes the derivative terms with respect to y</span>
<span class="w"> </span><span class="n">dual_array</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sin_2y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">admath</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="n">_rt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="w"> </span><span class="c1">// partial arrays are promoted as needed by overloaded operators</span>
<span class="w"> </span><span class="n">dual_array</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_squared</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin_2y</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="util.html" class="btn btn-neutral float-left" title="Helper Functions and Libraries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="unit_tests.html" class="btn btn-neutral float-right" title="Overview of Unit Tests" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Microphysics Development Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  


</body>
</html>